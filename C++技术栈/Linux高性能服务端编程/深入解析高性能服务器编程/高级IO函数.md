Linux提供了很多高级的I/O函数。它们并不像Linux基础I/O函数（比如open和read）那么常用（编写内核模块时一般要实现这些I/O函数），但在特定的条件下却表现出优秀的性能。  



本章将讨论其中和网络编程相关的几个，这些函数大致分为三类：  

- 用于创建文件描述符的函数，包括pipe、dup/dup2函数。
- 用于读写数据的函数，包括readv/writev、sendfile、mmap/munmap、splice和tee函数。  
- 用于控制I/O行为和属性的函数，包括fcntl函数。  



# pipe()

pipe函数可用于创建一个管道，以实现进程间通信。  

![image-20220913142121952](%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0.assets/image-20220913142121952.png)



pipe函数的参数是一个包含两个int型整数的数组指针。该函数成功时返回0，并将一对打开的文件描述符值填入其参数指向的数组。如果失败，则返回-1并设置errno  



通过pipe函数创建的这两个文件描述符fd[0]和fd[1]分别构成管道的两端，往fd[1]写入的数据可以从fd[0]读出。并且，==fd[0]只能用于从管道读出数据，fd[1]则只能用于往管道写入数据==，而不能反过来使用。  

如果要实现双向的数据传输，就应该使用两个管道。 



默认情况下，这一对文件描述符都是阻塞的。此时如果我们用read系统调用来读取一个空的管道，则read将被阻塞，直到管道内有数据可读；如果我们用write系统调用来往一个满的管道（见后文）中写入数据，则write亦将被阻塞，直到管道有足够多的空闲空间可用。  

>但如果应用程序将fd[0]和fd[1]都设置为非阻塞的，则read和write会有不同的行为。  



如果管道的写端文件描述符fd[1]的引用计数（见5.7节）减少至0，即没有任何进程需要往管道中写入数据，则针对该管道的读端文件描述符fd[0]的read操作将返回0，即读
取到了文件结束标记（End Of File，EOF）。

反之，如果管道的读端文件描述符fd[0]的引用计数减少至0，即没有任何进程需要从管道读取数据，则针对该管道的写端文件描述符fd[1]的write操作将失败，并引发SIGPIPE信号。  



管道内部传输的数据是字节流，这和TCP字节流的概念相同。但二者又有细微的区别。应用层程序能往一个TCP连接中写入多少字节的数据，取决于对方的接收通告窗口的大小和本端的拥塞窗口的大小。而管道本身拥有一个容量限制，它规定如果应用程序不将数据从管道读走的话，该管道最多能被写入多少字节的数据。自Linux 2.6.11内核起，管道容量的大小默认是65536字节。我们可以使用fcntl函数来修改管道容量（见后文）。  



此外，==socket的基础API中有一个socketpair函数。它能够方便地创建双向管道==。其定义如下：  

![image-20220913142422217](%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0.assets/image-20220913142422217.png)

socketpair前三个参数的含义与socket系统调用的三个参数完全相同，但domain只能使用UNIX本地域协议族AF_UNIX，因为我们仅能在本地使用这个双向管道。最后一个参数则和pipe系统调用的参数一样，只不过socketpair创建的这对文件描述符都是既可读又可写的。socketpair成功时返回0，失败时返回-1并设置errno。  



# dup()和dup2()

6.2节



# sendfile()

>[sendfile:Linux中的"零拷贝" - 摩斯电码 - 博客园 (cnblogs.com)](https://www.cnblogs.com/pengdonglin137/articles/7995528.html)


# TCP/IP协议族体系结构以及主要协议

TCP/IP协议族是一个四层协议系统，自底而上分别是：

1. 数据链路层
2. 网络层
3. 传输层
4. 应用层

![image-20220806145215038](TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F.assets/image-20220806145215038.png)



## 数据链路层

数据链路层实现了网卡接口的<font color="red">网络驱动程序</font>，以处理数据在物理媒介（比如以太网、令牌环等）上的传输。不同的物理网络具有不同的电气特性，网络驱动程序隐藏了这些细节，为上层协议提供一个统一的接口。  



两个常用的协议：

- ARP协议（Address Resolve Protocol，地址解析协议）
- RARP协议（Reverse Address Resolve Protocol，逆地址解析协议）  

它们<font color="red">实现了IP地址和机器物理地址（通常是MAC地址）之间的相互转换</font>。 
>以太网、令牌环和802.11无线网络都使用MAC地址  



==网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻址一台机器==，因此网络层必须先将目标机器的IP地址转化成其物理地址，才能使用数据链路层提供的服务，这就是ARP协议的用途。  

RARP
协议仅用于网络上的某些无盘工作站。因为缺乏存储设备，无盘工作站无法记住自己的IP地址，但它们可以利用网卡上的物理地址来向网络管理者（服务器或网络管理软件）查询自身的IP地址。运行RARP服务的网络管理者通常存有该网络上所有机器的物理地址到IP地址的映射。  



## 网络层

<u>*网络层实现数据包的选路和转发*</u>。

WAN（Wide Area Network，广域网）通常使用众多分级的路由器来连接分散的主机或LAN（Local
Area Network，局域网），*<u>因此，通信的两台主机一般不是直接相连的，而是通过多个中间节点（路由器）连接的</u>*。  

<font color="red">网络层的任务就是选择这些中间节点，以确定两台主机之间的通信路径</font>。  同时，网络层对上层协议隐藏了网络拓扑连接的细节，使得在传输层和网络应用程序看来，通信的双方是直接相连的。  



网络层最核心的协议是IP协议（Internet Protocol，因特网协议）。<font color="red">IP协议根据数据包的目的IP地址来决定如何投递它</font>。

如果数据包不能直接发送给目标主机，那么IP协议就为它寻找一个合适的下一跳（next
hop）路由器，并将数据包交付给该路由器来转发。多次重复这一过程，数据包最终到达目标主机，或者由于发送失败而被丢弃。可见，*<u>IP协议使用逐跳（hop by hop）的方式确定通信路径</u>*。  



网络层另外一个重要的协议是ICMP协议（Internet Control Message Protocol，因特网控制报文协议）。它是IP协议的重要补充，*<u>主要用于检测网络连接</u>*。  

ICMP协议使用的报文格式：
![image-20220806150640965](TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F.assets/image-20220806150640965.png)

8位类型字段用于区分报文类型。它将ICMP报文分为两大类：一类是差错报文，这类报文主要用来回应网络错误，比如目标不可到达（类型值为3）和重定向（类型值为5）；另一类是查询报文，这类报文用来查询网络信息，比如ping程序就是使用ICMP报文查看目标是否可到达（类型值为8）的。有的ICMP报文还使用8位代码字段来进一步细分不同的条件。比如重定向报文使用代码值0表示对网络重定向，代码值1表示对主机重定向。ICMP报文使用16位校验和字段对整个报文（包括头部和内容部分）进行循环冗余校验（Cyclic Redundancy Check，CRC），以检验报文在传输过程中是否损坏。  

>ICMP协议并非严格意义上的网络层协议，因为它使用处于同一层的IP协议提供的服务（一般来说，上层协议使用下层协议提供的服务）。  



## 传输层

传输层为两台主机上的应用程序***<u>==提供端到端（end to end）的通信==</u>***。  

> ==与网络层使用的逐跳通信方式不同，传输层只关心通信的起始端和目的端==，而不在乎数据包的中转过程。  

![image-20220806151019871](TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F.assets/image-20220806151019871.png)

>- 垂直的实线箭头表示TCP/IP协议族各层之间的实体通信（数据包确实是沿着这些线路传递的）  
>
>- 水平的虚线箭头表示逻辑通信线路  

可见：

- ==数据链路层（驱动程序）封装了物理网络的电气细节==；
- ==网络层封装了网络连接的细节==；
- ==传输层则为应用程序封装了一条端到端的逻辑通信链路==，它负责数据的收发、链路的超时重连等。  



传输层协议主要有三个：TCP协议、UDP协议和SCTP协议。  



TCP协议（Transmission Control Protocol，传输控制协议）为应用层提供可靠的、面向连接的和基于流（stream）的服务。TCP协议使用超时重传、数据确认等方式来确保数据包被正确地发送至目的端，因此TCP服务是可靠的。使用TCP协议通信的双方必须先建立TCP连接，并<u>*在内核中为该连接维持一些必要的数据结构*</u>，比如连接的状态、读写缓冲区，以及诸多定时器等。当通信结束时，双方必须关闭连接以释放这些内核数据。<u>*TCP服务是基于流的*</u>。基于流的数据没有边界（长度）限制，它源源不断地从通信的一端流入另一端。发送端可以逐个字节地向数据流中写入数据，接收端也可以逐个字节地将它们读出。  



UDP协议（User Datagram Protocol，用户数据报协议）则与TCP协议完全相反，它为应用层提供不可靠、无连接和<u>*基于数据报的服务*</u>。“不可靠”意味着UDP协议无法保证数据从发送端正确地传送到目的端。如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，则UDP协议只是简单地通知应用程序发送失败。因此，<u>*使用UDP协议的应用程序通常要自己处理数据确认、超时重传等逻*</u>辑。UDP协议是无连接的，即通信双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收端的地址（IP地址等信息）。基于数据报的服务，是相对基于流的服务而言的。<u>*每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断*</u>。  



## 应用层

应用层负责处理应用程序的逻辑。  

>数据链路层、网络层和传输层负责处理网络通信细节  



应用层协议很多：

- ping是应用程序，而不是协议，前面说过它利用ICMP报文检测网络连接，是调试网络环境的必备工具。  
- telnet协议是一种远程登录协议，它使我们能在本地完成远程任务，本书后续章节将会多次使用telnet客户端登录到其他服务上。  
- OSPF（Open Shortest Path First，开放最短路径优先）协议是一种动态路由更新协议，用于路由器之间的通信，以告知对方各自的路由信息。  
- DNS（Domain Name Service，域名服务）协议提供<u>*机器域名到IP地址的转换*</u>。



==应用层协议（或程序）可能跳过传输层直接使用网络层提供的服务==，比如ping程序和OSPF协议。  

应用层协议（或程序）通常既可以使用TCP服务，又可以使用UDP服务，比如DNS协议。  

>可以通过/etc/services文件查看所有知名的应用层协议，以及它们都能使用哪些传输层服务  



# 封装

![image-20220806170752382](TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F.assets/image-20220806170752382.png)

应用程序数据在发送到物理网络上之前，将沿着协议栈从上往下依次传递。每层协议都将在上层数据的基础上加上自己的头部信息（有时还包括尾部信息），以实现该层的功能。



## 封装TCP报文段（TCP message segment）

![image-20220806171103289](TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F.assets/image-20220806171103289.png)

当发送端应用程序使用send（或者write）函数向一个TCP连接写入数据时，内核中的TCP模块首先把这些数据复制到与该连接对应的TCP内核发送缓冲区中，然后TCP模块调用IP模块提供的服务，传递的参数包括TCP头部信息和TCP发送缓冲区中的数据，即TCP报文段。  



## 封装UDP数据报（UDP datagram）

UDP对应用程序数据的封装与TCP类似。不同的是，UDP无须为应用层数据保存副本，因为它提供的服务是不可靠的。当一个UDP数据报被成功发送之后，UDP内核缓冲区中的该数据报就被丢弃了。如果应用程序
检测到该数据报未能被接收端正确接收，并打算重发这个数据报，则应用程序需要重新从用户空间将该数据报拷贝到UDP内核发送缓冲区中。  



## 封装IP数据报（IP datagram）

IP数据报也包括头部信息和数据部分，其中数据部分就是一个TCP报文段、UDP数据报或者ICMP报文。  



## 封装以太网帧（frame）

经过数据链路层封装的数据称为帧（frame）。

传输媒介不同，帧的类型也不同。比如，以太网上传输的是以太网帧（ethernet frame），而令牌环网络上传输的则是令牌环帧（token ring frame）。  



以以太网帧为例，其封装格式如图1-6所示：

![image-20220806171525635](TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F.assets/image-20220806171525635.png)



帧的最大传输单元（Max Transmit Unit，MTU），即帧最多能携带多少上层协议数据（比如IP数据报），通常受到网络类型的限制。图1-6所示的以太网帧的MTU是1500字节。正因为如此，<u>*过长的IP数据报可能需要被分片（fragment）传输*</u>。  



帧才是最终在物理网络上传送的字节序列。  



# 分用

当帧到达目的主机时，将沿着协议栈自底向上依次传递。<u>*各层协议依次处理帧中本层负责的头部数据，以获取所需的信息，并最终将处理后的帧交给目标应用程序*</u>。这个过程称为分用（demultiplexing）。  



分用是依靠头部信息中的类型字段实现的。标准文档RFC 1700定义了所有标识上层协议的类型字段以及每个上层协议对应的数值。



![image-20220806171856016](TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F.assets/image-20220806171856016.png)





# ARP协议（数据链路层协议）

ARP协议能实现任意网络层地址到任意物理地址的转换，不过本书<font color="red"><u>*仅讨论从IP地址到以太网地址*</u>（MAC地址）的转换</font>。  



其工作原理是：主机向自己所在的网络广播一个ARP请求，该请求包含目标机器的网络地址。此网络上的其他机器都将收到这个请求，但<u>*只有被请求的目标机器会回应一个ARP应答，其中包含自己的物理地址*</u>。  



## 以太网ARP请求/应答报文详解  

以太网ARP请求/应答报文的格式：

![image-20220806172601541](TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F.assets/image-20220806172601541.png)

- 硬件类型字段定义物理地址的类型，它的值为1表示MAC地址。
- 协议类型字段表示要映射的协议地址类型，它的值为0x800，表示IP地址。  
- 硬件地址长度字段和协议地址长度字段，顾名思义，其单位是字节。对MAC地址来说，其长度为6；对IP（v4）地址来说，其长度为4。
- 操作字段指出4种操作类型：
  - ARP请求（值为1）
  - ARP应答（值为2）
  - RARP请求（值为3）
  - RARP应答（值为4）

- 最后4个字段指定通信双方的以太网地址和IP地址。
  - 发送端填充除目的端以太网地址外的其他3个字段，以构建ARP请求并发送之。
  - 接收端发现该请求的目的端IP地址是自己，就把自己的以太网地址填进去，然后交换两个目的端地址和两个发送端地址，以构建ARP应答并返回之。



由图1-9可知，ARP请求/应答报文的长度为28字节。如果再加上以太网帧头部和尾部的18字节（见图1-6），则一个携带ARP请求/应答报文的以太网帧长度为46字节。不过有的实现要求以太网帧数据部分长
度至少为46字节（见图1-4），此时ARP请求/应答报文将增加一些填充字节，以满足这个要求。在这种情况下，一个携带ARP请求/应答报文的以太网帧长度为64字节。  



## ARP高速缓存的查看和修改

通常，ARP维护一个高速缓存，其中包含经常访问（比如网关地址）或最近访问的机器的IP地址到物理地址的映射。这样就避免了重复的ARP请求，提高了发送数据包的速度。  



Linux下可以使用arp命令来查看和修改ARP高速缓存：

![image-20220806173532538](TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F.assets/image-20220806173532538.png)

其中，第一项描述的是另一台测试机器Kongming20，第二项描述的是路由器。  



下面两条命令则分别删除和添加一个ARP缓存项：  

![image-20220806173726643](TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F.assets/image-20220806173726643.png)



## 使用tcpdump观察ARP通信过程  

为了清楚地了解ARP的运作过程，我们从ernest-laptop上执行telnet命令登录Kongming20的echo服务（已经开启），并用tcpdump（详见第17章）抓取这个过程中两台测试机器之间交换的以太网帧。  

![image-20220806173923314](TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F.assets/image-20220806173923314.png)

1. 先清除ARP缓存中与Kongming20对应的项，否则ARP通信不被执行，我们也就无法抓取到期望的以太网帧；

2. 当执行telnet命令并在两台通信主机之间建立TCP连接后（telnet输出“Connected to 192.168.1.109”），输入Ctrl+]以调出telnet程序的命令提示符，然后在telnet命令提示符后输入quit，退出telnet客户端程序（因为ARP通信在TCP连接建立之前就已经完成，故我们不关心后续内容）

3. tcpdump抓取到的众多数据包中，只有最靠前的两个和ARP通信有关系，现在将它们列出（数据包前面的编号是笔者加入的）

   ![image-20220806174104336](TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F.assets/image-20220806174104336.png)



第一个数据包中，ARP通信的源端的物理地址是00:16:d3:5c:b9:e3（ernest-laptop），目的端的物理地址是ff:ff:ff:ff:ff:ff，这是以太网的广播地址，用以表示整个LAN。  该LAN上的所有机器都会收到并处理这样的帧。数值0x806是以太网帧头部的类型字段的值，它表示分用的目标是ARP模块。  该以太网帧的长度为42字节（实际上是46字节，tcpdump未统计以太网帧尾部4字节的CRC字段），其中数据部分长度为28字节。“Request”表示这是一个ARP请求，“who-has192.168.1.109 tell 192.168.1.108”则表示是ernest-laptop要查询Kongming20的IP地址。



第二个数据包中，ARP通信的源端的物理地址是08:00:27:53:10:67（Kongming20），目的端的物理地址是
00:16:d3:5c:b9:e3（ernest-laptop）。“Reply”表示这是一个ARP应答，“192.168.1.109 is-at 08:00:27:53:10:67”则表示目标机器Kongming20报告其物理地址。该以太网帧的长度为60字节（实际上是64字节），可见它使用了填充字节来满足最小帧长度。 



![image-20220806174310908](TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F.assets/image-20220806174310908.png)





# DNS协议（应用层协议）

我们通常使用机器的域名来访问这台机器，而不直接使用其IP地址，比如访问因特网上的各种网站。那么如何将机器的域名转换成IP地址呢？这就需要使用域名查询服务。



域名查询服务有很多种实现方式，比如NIS（Network Information Service，网络信息服务）、DNS和
本地静态文件等。本节主要讨论DNS。    



## DNS查询和应答报文详解

DNS是一套分布式的域名服务系统。每个DNS服务器上都存放着大量的机器名和IP地址的映射，并且是动态更新的。众多网络客户端程序都使用DNS协议来向DNS服务器查询目标主机的IP地址。  



DNS查询和应答报文的格式如图1-11所示：

![image-20220806174555232](TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F.assets/image-20220806174555232.png)



- 16位标识字段用于标记一对DNS查询和应答，以此区分一个DNS应答是哪个DNS查询的回应。

- 16位标志字段用于协商具体的通信方式和反馈通信状态。DNS报文头部的16位标志字段的细节如图1-12所示：

  ![image-20220806174644414](TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F.assets/image-20220806174644414.png)

  - QR，查询/应答标志。0表示这是一个查询报文，1表示这是一个应答报文。  
  - opcode，定义查询和应答的类型。0表示标准查询，1表示反向查询（由IP地址获得主机域名），2表示请求服务器状态
  - AA，授权应答标志，仅由应答报文使用。1表示域名服务器是授权服务器。
  - TC，截断标志，仅当DNS报文使用UDP服务时使用。因为UDP数据报有长度限制，所以过长的DNS报文将被截断。1表示DNS报文超过512字节，并被截断。
  - RD，递归查询标志。1表示执行递归查询，即如果目标DNS服务器无法解析某个主机名，则它将向其他DNS服务器继续查询，如此递归，直到获得结果并把该结果返回给客户端。0表示执行迭代查询，即如果目标DNS服务器无法解析某个主机名，则它将自己知道的其他DNS服务器的IP地址返回给客户端，以供客户端参考。  
  - RA，允许递归标志。仅由应答报文使用，1表示DNS服务器支持递归查询。  
  - zero，这3位未用，必须都设置为0。
  - rcode，4位返回码，表示应答的状态。常用值有0（无错误）和3（域名不存在）。  

- 接下来的4个字段则分别指出DNS报文的最后4个字段的资源记录数目。  

  - 对查询报文而言，它一般包含1个查询问题，而应答资源记录数、授权资源记录数和额外资源记录数则为0。  
  - 应答报文的应答资源记录数则至少为1，而授权资源记录数和额外资源记录数可为0或非0。

- 查询问题的格式如图1-13所示：

  ![image-20220806175107543](TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F.assets/image-20220806175107543.png)

  - 查询名以一定的格式封装了要查询的主机域名。  
  - 16位查询类型表示如何执行查询操作，常见的类型有如下几种：
    - 类型A，值是1，表示获取目标主机的IP地址。
    - 类型CNAME，值是5，表示获得目标主机的别名。  
    - 类型PTR，值是12，表示反向查询。  

- 应答字段、授权字段和额外信息字段都使用资源记录（ResourceRecord，RR）格式。  

  资源记录格式如图1-14所示：

  ![image-20220806175302497](TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F.assets/image-20220806175302497.png)

  - 32位域名是该记录中与资源对应的名字，其格式和查询问题中的查询名字段相同。16位类型和16位类字段的含义也与DNS查询问题的对应字段相同。  
  - 32位生存时间表示该查询记录结果可被本地客户端程序缓存多长时间，单位是秒。  
  - 16位资源数据长度字段和资源数据字段的内容取决于类型字段。对类型A而言，资源数据是32位的IPv4地址，而资源数据长度则为4（以字节为单位）。  

  

## Linux下访问DNS服务

我们要访问DNS服务，就<u>*必须先知道DNS服务器的IP地址*</u>。  

Linux使用/etc/resolv.conf文件来存放DNS服务器的IP地址。



机器ernest-laptop上，该文件的内容如下：  

![image-20220806175508686](TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F.assets/image-20220806175508686.png)

其中的两个IP地址分别是首选DNS服务器地址和备选DNS服务器地址。文件中的注释语句“Generated by Network Manager”告诉我们，这两个DNS服务器地址是由网络管理程序写入的。 

 

Linux下一个常用的访问DNS服务器的客户端程序是host，比如下面的命令是向首选DNS服务器219.239.26.42查询机器www.baidu.com的IP地址：  

![image-20220806180030003](TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F.assets/image-20220806180030003.png)

host命令的输出告诉我们，机器名www.baidu.com是www.a.shifen.com.的别名，并且该机器名对应两个IP地址。  



host命令使用DNS协议和DNS服务器通信，其-t选项告诉DNS协议使用哪种查询类型。我们这里使用的是A类型，即通过机器的域名获得其IP地址（但实际上返回的资源记录中还包含机器的别名）。关于host命令的详细使用方法，请参考其man手册。  



## 使用tcpdump观察DNS通信过程

下面我们将从ernest-laptop上运行host命令以查询主机www.baidu.com对应的IP地址，并使用tcpdump抓取这一过程中LAN上传输的以太网帧。  



具体的操作过程如下：  

![image-20220806180158272](TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F.assets/image-20220806180158272.png)

这一次执行tcpdump抓包时，我们使用“port domain”来过滤数据包，表示只抓取使用domain（域名）服务的数据包，即DNS查询和应答报文。  



tcpdump的输出如下：  

![image-20220806180244325](TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F.assets/image-20220806180244325.png)

这两个数据包开始的“IP”指出，它们后面的内容描述的是IP数据报。<u>*tcpdump以“IP地址.端口号”的形式来描述通信的某一端*</u>；以“＞”表示数据传输的方向，“＞”前面是源端，后面是目的端。  

- 第一个数据包是测试机器ernest-laptop（IP地址是192.168.1.108）向其首选DNS服务器（IP地址是219.239.26.42）发送的DNS查询报文（目标端口53是DNS服务使用的端口，这一点我们在前面介绍过）；

  数值57428是DNS查询报文的标识值，因此该值也出现在DNS应答报文中。“+”表示启用递归查询标志。“A?”表示使用A类型的查询方式。“www.baidu.com”则是DNS查询问题中的查询名。括号中的数值31是DNS查询报文的长度（以字节为单位）。  

- 第二个数据包是服务器反馈的DNS应答报文。  

  “3/4/4”表示该报文中包含3个应答资源记录、4个授权资源记录和4个额外信息记录。“CNAME www.a.shifen.com.，A 119.75.218.77，A 119.75.217.56”则表示3个应答资源记录的内容。其中CNAME表示紧随其后的记录是机器的别名，A表示紧随其后的记录是IP地址。该应答报文的长度为226字节。  



# socket和TCP/IP协议族的关系

数据链路层、网络层、传输层协议是在内核中实现的。因此操作系统需要实现一组系统调用，使得应用程序能够访问这些协议提供的服务。实现这组系统调用的API（ApplicationProgramming Interface，应用程序编程接口）主要有两套：socket和XTI。XTI现在基本不再使用，本书仅讨论socket。  

> 简而言之，socket是使用这套系统调用的API。



由socket定义的这一组API提供如下两点功能：

- 一是将应用程序数据==从用户缓冲区中复制到TCP/UDP内核发送缓冲区==，以交付内核来发送数据（比如图1-5所示的send函数）；

  或者是从内核TCP/UDP==接收缓冲区中复制数据到用户缓冲区==，以读取数据；

- 二是应用程序可以通过它们来修改内核中各层协议的某些头部信息或其他数据结构，从而精细地控制底层通信的行为。

  比如可以通过setsockopt函数来设置IP数据报在网络上的存活时间。



>socket是一套通用网络编程接口，它不但可以访问内核中TCP/IP协议栈，而且可以访问其他网络协议栈（比如X.25协议栈、UNIX本地域协议栈等）。










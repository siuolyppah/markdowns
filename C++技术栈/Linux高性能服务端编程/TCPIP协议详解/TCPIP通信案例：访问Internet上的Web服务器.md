# 本章内容

本章从如下四方面来讨论TCP协议：  

- TCP头部信息：

  TCP头部信息出现在每个TCP报文段中，用于指定通信的源端端口号、目的端端口号，管理TCP连接，控制两个方向的数据流。  

- TCP状态转移过程：

  TCP连接的任意一端都是一个状态机。在TCP连接从建立到断开的整个过程中，连接两端的状态机将经历不同的状态变迁。

- TCP数据流：

  讨论两种类型的TCP数据流：交互数据流和成块数据流。  

- TCP数据流的控制：

  为了保证可靠传输和提高网络通信质量，内核需要对TCP数据流进行控制。这一部分讨论TCP数据流控制的两个方面：超时重传和拥塞控制。  

  

# TCP服务的特点

传输层协议主要有两个：TCP协议和UDP协议。

==TCP协议相对于UDP协议的特点是：面向连接、字节流和可靠传输==。 



使用TCP协议通信的双方必须先建立连接，然后才能开始数据的读写。双方都必须为该连接分配必要的内核资源，以管理连接的状态和连接上数据的传输。TCP连接是全双工的，即双方的数据读写可以通过一个连接进行。完成数据交换之后，通信双方都必须断开连接以释放系统资源。  



TCP协议的这种连接是一对一的，所以基于广播和多播（目标是多个主机地址）的应用程序不能使用TCP服务。而==无连接协议UDP则非常适合于广播和多播==。  



- 对于TCP（字节流）：
  - 发送端应用程序连续执行多次写操作时，TCP模块先将这些数据放入TCP发送缓冲区中。当TCP模块真正开始发送数据时，发送缓冲区中这些等待发送的数据可能被封装成一个或多个TCP报文段发出。  
  - 当接收端收到一个或多个TCP报文段后，TCP模块将它们携带的应用程序数据按照TCP报文段的序号（见后文）依次放入TCP接收缓冲区中，并通知应用程序读取数据。接收端应用程序可以一次性将TCP接收缓冲区中的数据全部读出，也可以分多次读取，这取决于用户指定的应用程序读缓冲区的大小。
- 对于UDP（数据报）：
  - 发送端应用程序每执行一次写操作，UDP模块就将其封装成一个UDP数据报并发送之。 
  - 接收端必须及时针对每一个UDP数据报执行读操作（通过recvfrom系统调用），否则就会丢包（这经常发生在较慢的服务器上）。如果用户没有指定足够的应用程序缓冲区来读取UDP数据，则UDP数据将被截断。

![image-20220808210855083](TCPIP%E9%80%9A%E4%BF%A1%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%AE%BF%E9%97%AEInternet%E4%B8%8A%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8.assets/image-20220808210855083.png)



 

# TCP头部结构

3.2节



# TCP连接的建立和关闭

3.3节



# TCP状态转移

TCP连接的任意一端在任一时刻都处于某种状态，当前状态可以通
过netstat命令（见第17章）查看。  



TCP连接从建立到关闭的整个过程中通信两端状态的变化：

![image-20220808212332035](TCPIP%E9%80%9A%E4%BF%A1%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%AE%BF%E9%97%AEInternet%E4%B8%8A%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8.assets/image-20220808212332035.png)

- 粗虚线表示典型的服务器端连接的状态转移
- 粗实线表示典型的客户端连接的状态转移  



服务端：

1. 通过listen系统调用（见第5章）进入LISTEN状态，被动等待客户端连接，因此执行的是所谓的被动打开；
2. 服务器一旦监听到某个连接请求（收到同步报文段），就将该连接放入内核等待队列中，并向客户端发送带SYN标志的确认报文段。此时该连接处于SYN_RCVD状态；  
3. 如果服务器成功地接收到客户端发送回的确认报文段，则该连接转移到ESTABLISHED状态。ESTABLISHED状态是连接双方能够进行双向数据传输的状态；
4. 当客户端主动关闭连接时（通过close或shutdown系统调用向服务器发送结束报文段），服务器通过返回确认报文段使连接进入CLOSE_WAIT状态；
5. 通常，服务器检测到客户端关闭连接后，也会立即给客户端
   发送一个结束报文段来关闭连接。这将使连接转移LAST_ACK状态，以等待客户端对结束报文段的最后一次确认。一旦确认完成，连接就彻底关闭了。  



客户端：

1. 通过connect系统调用（见第5章）主动与服务器建立连接。
   connect系统调用首先给服务器发送一个同步报文段，使连接转移到SYN_SENT状态。  

   此后，connect系统调用可能因为如下两个原因失败返回：  

   - 如果connect连接的目标端口不存在（未被任何进程监听），或者该端口仍被处于TIME_WAIT状态的连接所占用（见后文），则服务器将给客户端发送一个复位报文段，connect调用失败。  
   - 如果目标端口存在，但connect在超时时间内未收到服务器的确
     认报文段，则connect调用失败。

   connect调用失败将使连接立即返回到初始的CLOSED状态。   

2. 如果客户端成功收到服务器的同步报文段和确认，则connect调用成功返回，连接转移至ESTABLISHED状态。  

3. 当客户端执行主动关闭时，它将向服务器发送一个结束报文段，同时连接进入FIN_WAIT_1状态。  

   若此时客户端收到服务器专门用于确认目的的确认报文段（比如图3-6中的TCP报文段5），则连接转移至FIN_WAIT_2状态。当客户端处于FIN_WAIT_2状态时，服务器处于CLOSE_WAIT状态，这一对状态是可能发生半关闭的状态。此时如果
   服务器也关闭连接（发送结束报文段），则客户端将给予确认并进入TIME_WAIT状态。  

![image-20220808213443069](TCPIP%E9%80%9A%E4%BF%A1%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%AE%BF%E9%97%AEInternet%E4%B8%8A%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8.assets/image-20220808213443069.png)




# 选择编译器

CMake将语言的编译器存储在`CMAKE_<LANG>_COMPILER`变量中，其中`<LANG>`是受支持的任何一种语言，对于我们的目的是`CXX`、`C`或`Fortran`。



两种方式：

1. 使用CLI中的`-D`选项，例如：

   ```sh
   $ cmake -D CMAKE_CXX_COMPILER=clang++ ..
   ```

2. 通过导出环境变量`CXX`(C++编译器)、`CC`(C编译器)和`FC`(Fortran编译器)。例如，使用这个命令使用`clang++`作为`C++`编译器：

   ```sh
   $ env CXX=clang++ cmake ..
   ```

   



# 设置编译器选项

CMake为调整或扩展编译器标志提供了很大的灵活性，您可以选择下面两种方法:

1. CMake将编译选项视为目标属性。因此，可以==根据每个目标设置编译选项==，而不需要覆盖CMake默认值。

   ```cmake
   add_library(geometry
     STATIC
       geometry_circle.cpp
       geometry_circle.hpp
   )
   target_compile_options(geometry
     PRIVATE ${flags}
   )
   
   add_executable(compute-areas compute-areas.cpp)
   target_compile_options(compute-areas
     PRIVATE "-fPIC"
   )
   
   target_link_libraries(compute-areas geometry)
   ```

2. 可以使用`-D`CLI标志直接修改`CMAKE_<LANG>_FLAGS_<CONFIG>`变量。这将==影响项目中的所有目标==，并覆盖或扩展CMake默认值。

   ```sh
   cmake -D CMAKE_CXX_FLAGS="-fno-exceptions -fno-rtti" ..
   ```

> cmake --build . -- VERBOSE=1可以验证结果。





编译选项可以添加三个级别的可见性：`INTERFACE`、`PUBLIC`和`PRIVATE`。

- **PRIVATE**，编译选项会应用于给定的目标，不会传递给与目标相关的目标。

  > 我们的示例中， 即使`compute-areas`将链接到`geometry`库，`compute-areas`也不会继承`geometry`目标上设置的编译器选项。

- **INTERFACE**，给定的编译选项将只应用于指定目标，并传递给与目标相关的目标。

- **PUBLIC**，编译选项将应用于指定目标和使用它的目标。



# 设置语言标准

```cmake
add_library(animals
  SHARED
    Animal.cpp
    Animal.hpp
  )

set_target_properties(animals
  PROPERTIES
    CXX_STANDARD 14
    CXX_EXTENSIONS OFF
    CXX_STANDARD_REQUIRED ON
    POSITION_INDEPENDENT_CODE 1
)
```

>- **CXX_STANDARD**会设置我们想要的标准。
>- **CXX_EXTENSIONS**告诉CMake，只启用`ISO C++`标准的编译器标志，而不使用特定编译器的扩展。
>
>- **CXX_STANDARD_REQUIRED**指定所选标准的版本。如果这个版本不可用，CMake将停止配置并出现错误。当这个属性被设置为`OFF`时，CMake将寻找下一个标准的最新版本，直到一个合适的标志。



==全局设置==：

可以将`CMAKE_<LANG>_STANDARD`、`CMAKE_<LANG>_EXTENSIONS`和`CMAKE_<LANG>_STANDARD_REQUIRED`变量设置为相应的值。所有目标上的对应属性都将使用这些设置。


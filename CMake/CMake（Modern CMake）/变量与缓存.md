# 本地变量

- 声明一个本地变量：

  ```cmake
  set(MY_VARIABLE "value" )
  ```

- 解析：通过 `${}` 来解析一个变量，例如 `${MY_VARIABLE}`

- 变量具有作用域的概念，因此若需要在父级文件中引用变量，需要：
  ```cmake
  set(MY_VARIABLE "value" PARENT_SCOPE)
  ```



- 如果变量的值不含有空格，则可以省略引号。

  > 但涉及到解析时，往往应`"${MY_PATH}"`



- 列表：列表就是简单地**包含一系列变量**。

  ```cmake
  set(MY_LIST "one" "two")
  ```

  也可以通过 `;` 分隔变量，这和空格的作用是一样的：

  ```cmake
  set(MY_LIST "one;two")
  ```

  



# 缓存变量

- CMake 提供了缓存变量，来允许==你从命令行中设置变量==。

- ```cmake
  set(<variable> <value>... CACHE <type> <docstring> [FORCE])
  ```

  - variable：变量名称

  - value：变量值列表

  - CACHE：cache变量的标志

  - type：变量类型，取决于变量的值。类型分为：BOOL、FILEPATH、PATH、STRING、INTERNAL

  - docstring：必须是字符串，作为变量概要说明

  - FORCE：强制选项，强制修改变量值

    >如果变量先前未定义,，或者使用了`FORCE`选项，则缓存条目会直接被赋值。
  
  例如：
  
  ```cmake
  set(MY_CACHE_VARIABLE "ITS_VALUE" CACHE STRING "ITS_Description")
  ```









测试如下：

```cmake
cmake_minimum_required(VERSION 3.11)

project(MyProject VERSION 1.0
    DESCRIPTION "Very nice project"
    LANGUAGES CXX)

set(VAR "value1" CACHE STRING "not FORCE")
message("1: ${VAR}")

set(VAR "value2" CACHE STRING "force" FORCE)
message("2: ${VAR}")

set(VAR "value3" CACHE STRING "force" FORCE)
message("3: ${VAR}")

set(VAR "value4" CACHE STRING "not FORCE")
message("4: ${VAR}")
```

```
1: value1
2: value2
3: value3
4: value3
```

结论：

- ==只要在set的时候，变量未定义，或者加了FORCE选项，就会进行赋值；否则赋值无效==。



# ~~环境变量~~

- 可以通过 `set(ENV{variable_name} value)` 和 `$ENV{variable_name}` 来设置和获取环境变量。



# 属性

- 设置属性：

  ```cmake
  set_property(TARGET TargetName
               PROPERTY CXX_STANDARD 11)
  
  set_target_properties(TargetName PROPERTIES
                        CXX_STANDARD 11)
  ```

- 获取属性：

  ```cmake
  get_property(ResultVariable TARGET TargetName PROPERTY CXX_STANDARD)
  ```

  
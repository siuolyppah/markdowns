# ç›¸å¯¹äºä½¿ç”¨ç®¡ç¨‹çš„ç‰¹ç‚¹

éƒ½æ˜¯ä¸ºäº†è§£å†³å¹¶å‘å¸¦æ¥çš„æ‰§è¡Œç»“æœä¸å¯é¢„æœŸçš„é—®é¢˜ã€‚ä½†ï¼š

- ä½¿ç”¨ç®¡ç¨‹ï¼ˆsynchronizedï¼‰ï¼šæ‚²è§‚é”
- ä½¿ç”¨æ— é”å¹¶å‘ï¼šä¹è§‚é”



# æœ¬ç« å†…å®¹

- CAS ä¸ volatile
- åŸå­æ•´æ•°ï¼šJDKæä¾›çš„åŸºäºæ— é”å¹¶å‘çš„å…¸å‹å®ç°
- åŸå­å¼•ç”¨
- åŸå­ç´¯åŠ å™¨
- Unsafeç±»



# CASçš„æ¡ˆä¾‹

- æ¥å£ï¼š

  ```java
  interface Account {
      // è·å–ä½™é¢
      Integer getBalance();
      // å–æ¬¾
      void withdraw(Integer amount);
  
      /**
       * æ–¹æ³•å†…ä¼šå¯åŠ¨ 1000 ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹åš -10 å…ƒ çš„æ“ä½œ
       * å¦‚æœåˆå§‹ä½™é¢ä¸º 10000 é‚£ä¹ˆæ­£ç¡®çš„ç»“æœåº”å½“æ˜¯ 0
       */
      static void demo(Account account) {
          List<Thread> ts = new ArrayList<>();
          long start = System.nanoTime();
          for (int i = 0; i < 1000; i++) {
              ts.add(new Thread(() -> {
                  account.withdraw(10);
              }));
          }
          ts.forEach(Thread::start);
          ts.forEach(t -> {
              try {
                  t.join();
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          });
          long end = System.nanoTime();
          System.out.println(account.getBalance()
                  + " cost: " + (end-start)/1000_000 + " ms");
      }
  }
  ```

- æ— é”çš„å®ç°ç±»ï¼š

  ```java
  public class AccountCas implements Account {
      private AtomicInteger balance;
  
      public AccountCas(Integer balance) {
          this.balance = new AtomicInteger(balance);
      }
  
      @Override
      public Integer getBalance() {
          return this.balance.get();
      }
  
      @Override
      public void withdraw(Integer amount) {
          while (true) {
              int prev = balance.get();
              int next = prev - amount;
  
              // (expectedValue, newValue)
              if (balance.compareAndSet(prev, next)) {
                  break;
              }
          }
      }
  
      public static void main(String[] args) {
          Account account = new AccountCas(10000);
          Account.demo(account);
      }
  }
  ```

  

# CASä¸volatile

## æ¡ˆä¾‹åˆ†æ

å‰é¢çœ‹åˆ°çš„ AtomicInteger çš„è§£å†³æ–¹æ³•ï¼Œ**å†…éƒ¨å¹¶æ²¡æœ‰ç”¨é”æ¥ä¿æŠ¤å…±äº«å˜é‡çš„çº¿ç¨‹å®‰å…¨**ã€‚é‚£ä¹ˆå®ƒæ˜¯å¦‚ä½•å®ç°çš„å‘¢ï¼Ÿ

```java
public void withdraw(Integer amount) {
    while(true) {
        // éœ€è¦ä¸æ–­å°è¯•ï¼Œç›´åˆ°æˆåŠŸä¸ºæ­¢
        while (true) {
            // æ¯”å¦‚æ‹¿åˆ°äº†æ—§å€¼ 1000
            int prev = balance.get();
            // åœ¨è¿™ä¸ªåŸºç¡€ä¸Š 1000-10 = 990
            int next = prev - amount;
            
            /*
             compareAndSet æ­£æ˜¯åšè¿™ä¸ªæ£€æŸ¥ï¼Œåœ¨ set å‰ï¼Œå…ˆæ¯”è¾ƒ prev ä¸å½“å‰å€¼
             - ä¸ä¸€è‡´äº†ï¼Œnext ä½œåºŸï¼Œè¿”å› false è¡¨ç¤ºå¤±è´¥
             æ¯”å¦‚ï¼Œåˆ«çš„çº¿ç¨‹å·²ç»åšäº†å‡æ³•ï¼Œå½“å‰å€¼å·²ç»è¢«å‡æˆäº† 990
             é‚£ä¹ˆæœ¬çº¿ç¨‹çš„è¿™æ¬¡ 990 å°±ä½œåºŸäº†ï¼Œè¿›å…¥ while ä¸‹æ¬¡å¾ªç¯é‡è¯•
             - ä¸€è‡´ï¼Œä»¥ next è®¾ç½®ä¸ºæ–°å€¼ï¼Œè¿”å› true è¡¨ç¤ºæˆåŠŸ
             */
            if (balance.compareAndSet(prev, next)) {
                break;
            }
        }
    }
}
```

å…¶ä¸­çš„å…³é”®æ˜¯ compareAndSetï¼Œå®ƒçš„ç®€ç§°å°±æ˜¯ CAS ï¼ˆä¹Ÿæœ‰ Compare And Swap çš„è¯´æ³•ï¼‰ï¼Œå®ƒå¿…é¡»æ˜¯**åŸå­æ“ä½œ**ã€‚

> CASæ“ä½œï¼Œæ˜¯åœ¨CPUæŒ‡ä»¤é›†çº§åˆ«ä¸Šï¼ˆX86æ¶æ„çš„lock cmpxchgæŒ‡ä»¤ï¼‰æä¾›çš„æ”¯æŒã€‚
>
> ***èƒ½ä¿è¯æ¯”è¾ƒå¹¶äº¤æ¢æ“ä½œçš„åŸå­æ€§***ã€‚
>
> > åœ¨å¤šæ ¸çŠ¶æ€ä¸‹ï¼ŒæŸä¸ªæ ¸æ‰§è¡Œåˆ°å¸¦ lock çš„æŒ‡ä»¤æ—¶ï¼ŒCPU ä¼šè®©æ€»çº¿é”ä½ï¼Œå½“è¿™ä¸ªæ ¸æŠŠæ­¤æŒ‡ä»¤æ‰§è¡Œå®Œæ¯•ï¼Œå†å¼€å¯æ€»çº¿ã€‚è¿™ä¸ªè¿‡ç¨‹ä¸­ä¸ä¼šè¢«çº¿ç¨‹çš„è°ƒåº¦æœºåˆ¶æ‰€æ‰“æ–­ï¼Œä¿è¯äº†å¤šä¸ªçº¿ç¨‹å¯¹å†…å­˜æ“ä½œçš„å‡†ç¡®æ€§ï¼Œæ˜¯åŸå­çš„ã€‚



![image-20220514170128704](%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%97%A0%E9%94%81.assets/image-20220514170128704.png)



## volatile

è·å–å…±äº«å˜é‡æ—¶ï¼Œä¸ºäº†ä¿è¯è¯¥å˜é‡çš„å¯è§æ€§ï¼Œéœ€è¦ä½¿ç”¨ volatile ä¿®é¥°ã€‚

å®ƒå¯ä»¥ç”¨æ¥ä¿®é¥°æˆå‘˜å˜é‡å’Œé™æ€æˆå‘˜å˜é‡ï¼Œä»–å¯ä»¥**é¿å…çº¿ç¨‹ä»è‡ªå·±çš„å·¥ä½œç¼“å­˜ä¸­æŸ¥æ‰¾å˜é‡çš„å€¼ï¼Œå¿…é¡»åˆ°ä¸»å­˜ä¸­è·å–å®ƒçš„å€¼**ï¼Œçº¿ç¨‹æ“ä½œ volatile å˜é‡éƒ½æ˜¯ç›´æ¥æ“ä½œä¸»å­˜ã€‚å³ä¸€ä¸ªçº¿ç¨‹å¯¹ volatile å˜é‡çš„ä¿®æ”¹ï¼Œå¯¹å¦ä¸€ä¸ªçº¿ç¨‹å¯è§ã€‚

> #### ğŸ’¡æ³¨æ„
>
> volatile ä»…ä»…ä¿è¯äº†å…±äº«å˜é‡çš„å¯è§æ€§ï¼Œè®©å…¶å®ƒçº¿ç¨‹èƒ½å¤Ÿçœ‹åˆ°æœ€æ–°å€¼ï¼Œä½†ä¸èƒ½è§£å†³æŒ‡ä»¤äº¤é”™é—®é¢˜ï¼ˆä¸èƒ½ä¿è¯åŸå­æ€§ï¼‰

CAS å¿…é¡»å€ŸåŠ© volatile æ‰èƒ½è¯»å–åˆ°å…±äº«å˜é‡çš„æœ€æ–°å€¼æ¥å®ç°ã€æ¯”è¾ƒå¹¶äº¤æ¢ã€‘çš„æ•ˆæœ



`AtomicInteger`ç±»ï¼š

```java
public class AtomicInteger extends Number implements java.io.Serializable {
	
    ...
    private volatile int value;
}
```



## ä¸ºä»€ä¹ˆæ— é”æ•ˆç‡é«˜

- æ— é”æƒ…å†µä¸‹ï¼Œå³ä½¿é‡è¯•å¤±è´¥ï¼Œçº¿ç¨‹å§‹ç»ˆåœ¨é«˜é€Ÿè¿è¡Œï¼Œæ²¡æœ‰åœæ­‡ï¼›
- è€Œ synchronized ä¼šè®©çº¿ç¨‹åœ¨æ²¡æœ‰è·å¾—é”çš„æ—¶å€™ï¼Œå‘ç”Ÿä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œè¿›å…¥é˜»å¡ã€‚



## CASçš„ç‰¹ç‚¹

ç»“åˆ CAS å’Œ volatile å¯ä»¥å®ç°æ— é”å¹¶å‘ï¼Œ**é€‚ç”¨äºçº¿ç¨‹æ•°å°‘ã€å¤šæ ¸ CPU çš„åœºæ™¯**ä¸‹ã€‚

- CAS æ˜¯åŸºäº**ä¹è§‚é”**çš„æ€æƒ³ï¼šæœ€ä¹è§‚çš„ä¼°è®¡ï¼Œä¸æ€•åˆ«çš„çº¿ç¨‹æ¥ä¿®æ”¹å…±äº«å˜é‡ï¼Œå°±ç®—æ”¹äº†ä¹Ÿæ²¡å…³ç³»ï¼Œæˆ‘åƒäºç‚¹å†é‡è¯•å‘—ã€‚
- synchronized æ˜¯åŸºäº**æ‚²è§‚é”**çš„æ€æƒ³ï¼šæœ€æ‚²è§‚çš„ä¼°è®¡ï¼Œå¾—é˜²ç€å…¶å®ƒçº¿ç¨‹æ¥ä¿®æ”¹å…±äº«å˜é‡ï¼Œæˆ‘ä¸Šäº†é”ä½ ä»¬éƒ½åˆ«æƒ³ æ”¹ï¼Œæˆ‘æ”¹å®Œäº†è§£å¼€é”ï¼Œä½ ä»¬æ‰æœ‰æœºä¼šã€‚
- CAS ä½“ç°çš„æ˜¯**æ— é”å¹¶å‘ã€æ— é˜»å¡å¹¶å‘**ï¼Œè¯·ä»”ç»†ä½“ä¼šè¿™ä¸¤å¥è¯çš„æ„æ€
  - å› ä¸ºæ²¡æœ‰ä½¿ç”¨ synchronizedï¼Œæ‰€ä»¥çº¿ç¨‹ä¸ä¼šé™·å…¥é˜»å¡ï¼Œè¿™æ˜¯æ•ˆç‡æå‡çš„å› ç´ ä¹‹ä¸€
  - ä½†å¦‚æœç«äº‰æ¿€çƒˆï¼Œå¯ä»¥æƒ³åˆ°é‡è¯•å¿…ç„¶é¢‘ç¹å‘ç”Ÿï¼Œåè€Œæ•ˆç‡ä¼šå—å½±å“



# åŸå­æ•´æ•°

J.U.C å¹¶å‘åŒ…æä¾›äº†ï¼š

- AtomicBoolean
- AtomicInteger
- AtomicLong



ä»¥ AtomicInteger ä¸ºä¾‹ï¼š

```java
AtomicInteger i = new AtomicInteger(0);

// è·å–å¹¶è‡ªå¢ï¼ˆi = 0, ç»“æœ i = 1, è¿”å› 0ï¼‰ï¼Œç±»ä¼¼äº i++
System.out.println(i.getAndIncrement());

// è‡ªå¢å¹¶è·å–ï¼ˆi = 1, ç»“æœ i = 2, è¿”å› 2ï¼‰ï¼Œç±»ä¼¼äº ++i
System.out.println(i.incrementAndGet());

// è‡ªå‡å¹¶è·å–ï¼ˆi = 2, ç»“æœ i = 1, è¿”å› 1ï¼‰ï¼Œç±»ä¼¼äº --i
System.out.println(i.decrementAndGet());

// è·å–å¹¶è‡ªå‡ï¼ˆi = 1, ç»“æœ i = 0, è¿”å› 1ï¼‰ï¼Œç±»ä¼¼äº i--
System.out.println(i.getAndDecrement());

// è·å–å¹¶åŠ å€¼ï¼ˆi = 0, ç»“æœ i = 5, è¿”å› 0ï¼‰
System.out.println(i.getAndAdd(5));

// åŠ å€¼å¹¶è·å–ï¼ˆi = 5, ç»“æœ i = 0, è¿”å› 0ï¼‰
System.out.println(i.addAndGet(-5));

// è·å–å¹¶æ›´æ–°ï¼ˆi = 0, p ä¸º i çš„å½“å‰å€¼, ç»“æœ i = -2, è¿”å› 0ï¼‰
// å…¶ä¸­å‡½æ•°ä¸­çš„æ“ä½œèƒ½ä¿è¯åŸå­ï¼Œä½†å‡½æ•°éœ€è¦æ— å‰¯ä½œç”¨
System.out.println(i.getAndUpdate(p -> p - 2));

// æ›´æ–°å¹¶è·å–ï¼ˆi = -2, p ä¸º i çš„å½“å‰å€¼, ç»“æœ i = 0, è¿”å› 0ï¼‰
// å…¶ä¸­å‡½æ•°ä¸­çš„æ“ä½œèƒ½ä¿è¯åŸå­ï¼Œä½†å‡½æ•°éœ€è¦æ— å‰¯ä½œç”¨
System.out.println(i.updateAndGet(p -> p + 2));

// è·å–å¹¶è®¡ç®—ï¼ˆi = 0, p ä¸º i çš„å½“å‰å€¼, x ä¸ºå‚æ•°1, ç»“æœ i = 10, è¿”å› 0ï¼‰
// å…¶ä¸­å‡½æ•°ä¸­çš„æ“ä½œèƒ½ä¿è¯åŸå­ï¼Œä½†å‡½æ•°éœ€è¦æ— å‰¯ä½œç”¨
// getAndUpdate å¦‚æœåœ¨ lambda ä¸­å¼•ç”¨äº†å¤–éƒ¨çš„å±€éƒ¨å˜é‡ï¼Œè¦ä¿è¯è¯¥å±€éƒ¨å˜é‡æ˜¯ final çš„
// getAndAccumulate å¯ä»¥é€šè¿‡ å‚æ•°1 æ¥å¼•ç”¨å¤–éƒ¨çš„å±€éƒ¨å˜é‡ï¼Œä½†å› ä¸ºå…¶ä¸åœ¨ lambda ä¸­å› æ­¤ä¸å¿…æ˜¯ final
System.out.println(i.getAndAccumulate(10, (p, x) -> p + x));

// è®¡ç®—å¹¶è·å–ï¼ˆi = 10, p ä¸º i çš„å½“å‰å€¼, x ä¸ºå‚æ•°1, ç»“æœ i = 0, è¿”å› 0ï¼‰
// å…¶ä¸­å‡½æ•°ä¸­çš„æ“ä½œèƒ½ä¿è¯åŸå­ï¼Œä½†å‡½æ•°éœ€è¦æ— å‰¯ä½œç”¨
System.out.println(i.accumulateAndGet(-10, (p, x) -> p + x));
```



# åŸå­å¼•ç”¨

## å¸¸è§çš„åŸå­å¼•ç”¨åŒ…è£…ç±»

- AtomicReference
- AtomicMarkableReference
- AtomicStampedReference

> #### ğŸ’¡æ³¨æ„
>
> åŸå­å¼•ç”¨çš„CASæ“ä½œï¼Œæ¯”è¾ƒçš„æ˜¯å¼•ç”¨å€¼ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåˆ¤æ–­æ˜¯å¦æŒ‡å‘åŒä¸€ä¸ªå¯¹è±¡ã€‚



## åŸå­å¼•ç”¨çš„æ¡ˆä¾‹

- æ¥å£ï¼š

  ```java
  public interface DecimalAccount {
      
      BigDecimal getBalance();		// æ³¨æ„æ˜¯åŒ…è£…ç±»ç±»å‹
      void withdraw(BigDecimal amount);	// å–æ¬¾
      
  /**
   * æ–¹æ³•å†…ä¼šå¯åŠ¨ 1000 ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹åš -10 å…ƒ çš„æ“ä½œ
   * å¦‚æœåˆå§‹ä½™é¢ä¸º 10000 é‚£ä¹ˆæ­£ç¡®çš„ç»“æœåº”å½“æ˜¯ 0
   */
      static void demo(DecimalAccount account) {
          List<Thread> ts = new ArrayList<>();
          for (int i = 0; i < 1000; i++) {
              ts.add(new Thread(() -> {
                  account.withdraw(BigDecimal.TEN);
              }));
          }
          ts.forEach(Thread::start);
          ts.forEach(t -> {
              try {
                  t.join();
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          });
          System.out.println(account.getBalance());
      }
  }
  ```

- åŸºäºsynchronizedï¼š

  ```java
  class DecimalAccountSafeLock implements DecimalAccount {
      private final Object lock = new Object();
      BigDecimal balance;
      
      public DecimalAccountSafeLock(BigDecimal balance) {
          this.balance = balance;
      }
      
      @Override
      public BigDecimal getBalance() {
          return balance;
      }
      
      @Override
      public void withdraw(BigDecimal amount) {
          synchronized (lock) {
              BigDecimal balance = this.getBalance();
              this.balance = balance.subtract(amount);
          }
      }
  }
  ```

- CASå®ç°ç±»ï¼š

  ```java
  class DecimalAccountSafeCas implements DecimalAccount {
      AtomicReference<BigDecimal> ref;
  
      public DecimalAccountSafeCas(BigDecimal balance) {
          ref = new AtomicReference<>(balance);
      }
  
      @Override
      public BigDecimal getBalance() {
          return ref.get();
      }
  
      @Override
      public void withdraw(BigDecimal amount) {
          while (true) {
              BigDecimal prev = ref.get();
              BigDecimal next = prev.subtract(amount);
              if (ref.compareAndSet(prev, next)) {
                  break;
              }
          }
      }
  }
  ```

  

## ABAé—®é¢˜åŠè§£å†³

### ABAé—®é¢˜

- æµ‹è¯•ç±»ï¼š

  ```java
  @Slf4j(topic = "c.Test36")
  public class Test36 {
  
      static AtomicReference<String> ref = new AtomicReference<>("A");
  
      public static void main(String[] args) throws InterruptedException {
          log.debug("main start...");
          String prev = ref.get();
          other();
          sleep(1000);
          // å°è¯•æ”¹ä¸º C
          log.debug("change A->C {}", ref.compareAndSet(prev, "C"));
      }
  
      private static void other() {
          new Thread(() -> {
              log.debug("change A->B {}", ref.compareAndSet(ref.get(), "B"));
          }, "t1").start();
          new Thread(() -> {
              log.debug("change B->A {}", ref.compareAndSet(ref.get(), "A"));
          }, "t2").start();
      }
  }
  ```

- æ—¥å¿—è¾“å‡ºï¼š

  ```
  17:16:00 [main] c.Test36 - main start...
  17:16:00 [t1] c.Test36 - change A->B true
  17:16:00 [t2] c.Test36 - change B->A true
  17:16:01 [main] c.Test36 - change A->C true
  ```

ä¸»çº¿ç¨‹ä»…èƒ½åˆ¤æ–­å‡ºå…±äº«å˜é‡çš„å€¼ä¸æœ€åˆå€¼ A æ˜¯å¦ç›¸åŒï¼Œä¸èƒ½æ„ŸçŸ¥åˆ°è¿™ç§ä» A æ”¹ä¸º B åˆ æ”¹å› A çš„æƒ…å†µã€‚è¿™ç§é—®é¢˜ç§°ä¹‹ä¸ºABAé—®é¢˜ã€‚

> åœ¨å¤§éƒ¨åˆ†çš„ä¸šåŠ¡é€»è¾‘ä¸‹ï¼ŒABAé—®é¢˜ä¸ä¼šäº§ç”Ÿé—®é¢˜ã€‚



### AtomicStampedReferenceè§£å†³

å¦‚æœå¸Œæœ›åªè¦æœ‰å…¶å®ƒçº¿ç¨‹ã€åŠ¨è¿‡äº†ã€‘å…±äº«å˜é‡ï¼Œé‚£ä¹ˆè‡ªå·±çš„ cas å°±ç®—å¤±è´¥ï¼Œè¿™æ—¶ï¼Œä»…æ¯”è¾ƒå€¼æ˜¯ä¸å¤Ÿçš„ï¼Œéœ€è¦å†åŠ ä¸€ä¸ª**ç‰ˆæœ¬å·**`AtomicStampedReference`ï¼š

```java
@Slf4j(topic = "c.Test36")
public class Test36 {

    static AtomicStampedReference<String> ref = new AtomicStampedReference<>("A", 0);

    public static void main(String[] args) throws InterruptedException {
        log.debug("main start...");
        // è·å–å€¼ A
        String prev = ref.getReference();
        // è·å–ç‰ˆæœ¬å·
        int stamp = ref.getStamp();
        log.debug("ç‰ˆæœ¬ {}", stamp);
        // å¦‚æœä¸­é—´æœ‰å…¶å®ƒçº¿ç¨‹å¹²æ‰°ï¼Œå‘ç”Ÿäº† ABA ç°è±¡
        other();
        sleep(2000);
        // å°è¯•æ”¹ä¸º C
        log.debug("change A->C {}", ref.compareAndSet(prev, "C", stamp, stamp + 1));
    }

    private static void other() throws InterruptedException {
        new Thread(() -> {
            log.debug("change A->B {}", ref.compareAndSet(ref.getReference(), "B",
                    ref.getStamp(), ref.getStamp() + 1));
            log.debug("æ›´æ–°ç‰ˆæœ¬ä¸º {}", ref.getStamp());
        }, "t1").start();
        sleep(1000);

        new Thread(() -> {
            log.debug("change B->A {}", ref.compareAndSet(ref.getReference(), "A",
                    ref.getStamp(), ref.getStamp() + 1));
            log.debug("æ›´æ–°ç‰ˆæœ¬ä¸º {}", ref.getStamp());
        }, "t2").start();
    }
}
```

```
17:27:41 [main] c.Test36 - main start...
17:27:41 [main] c.Test36 - ç‰ˆæœ¬ 0
17:27:41 [t1] c.Test36 - change A->B true
17:27:41 [t1] c.Test36 - æ›´æ–°ç‰ˆæœ¬ä¸º 1
17:27:42 [t2] c.Test36 - change B->A true
17:27:42 [t2] c.Test36 - æ›´æ–°ç‰ˆæœ¬ä¸º 2
17:27:44 [main] c.Test36 - change A->C false
```

> æ¯æ¬¡ä¿®æ”¹ï¼Œéƒ½ä¼šä½¿å¾—ç‰ˆæœ¬å·+1



### AtomicMarkableReferenceè§£å†³

>AtomicMarkableReferenceä»…å…³æ³¨äºï¼šæ˜¯å¦æœ‰è¿‡ä¿®æ”¹

```java
class GarbageBag {
    String desc;
    
    public GarbageBag(String desc) {
        this.desc = desc;
    }
    
    public void setDesc(String desc) {
        this.desc = desc; 
    }
    
    @Override
    public String toString() {
        return super.toString() + " " + desc;
    }
}
```

```java
@Slf4j
public class TestABAAtomicMarkableReference {
    public static void main(String[] args) throws InterruptedException {
        GarbageBag bag = new GarbageBag("è£…æ»¡äº†åƒåœ¾");
        // å‚æ•°2 mark å¯ä»¥çœ‹ä½œä¸€ä¸ªæ ‡è®°ï¼Œè¡¨ç¤ºåƒåœ¾è¢‹æ»¡äº†
        AtomicMarkableReference<GarbageBag> ref = new AtomicMarkableReference<>(bag, true);
        
        log.debug("ä¸»çº¿ç¨‹ start...");
        GarbageBag prev = ref.getReference();
        log.debug(prev.toString());
        
        new Thread(() -> {
            log.debug("æ‰“æ‰«å«ç”Ÿçš„çº¿ç¨‹ start...");
            bag.setDesc("ç©ºåƒåœ¾è¢‹");
            while (!ref.compareAndSet(bag, bag, true, false)) {}
            log.debug(bag.toString());
        }).start();
        
        Thread.sleep(1000);
        log.debug("ä¸»çº¿ç¨‹æƒ³æ¢ä¸€åªæ–°åƒåœ¾è¢‹ï¼Ÿ");
        boolean success = ref.compareAndSet(prev, new GarbageBag("ç©ºåƒåœ¾è¢‹"), true, false);
        log.debug("æ¢äº†ä¹ˆï¼Ÿ" + success);
        
        log.debug(ref.getReference().toString());
    }
}

```

```
2019-10-13 15:30:09.264 [main] ä¸»çº¿ç¨‹ start... 
2019-10-13 15:30:09.270 [main] cn.itcast.GarbageBag@5f0fd5a0 è£…æ»¡äº†åƒåœ¾
2019-10-13 15:30:09.293 [Thread-1] æ‰“æ‰«å«ç”Ÿçš„çº¿ç¨‹ start... 
2019-10-13 15:30:09.294 [Thread-1] cn.itcast.GarbageBag@5f0fd5a0 ç©ºåƒåœ¾è¢‹
2019-10-13 15:30:10.294 [main] ä¸»çº¿ç¨‹æƒ³æ¢ä¸€åªæ–°åƒåœ¾è¢‹ï¼Ÿ
2019-10-13 15:30:10.294 [main] æ¢äº†ä¹ˆï¼Ÿfalse 
2019-10-13 15:30:10.294 [main] cn.itcast.GarbageBag@5f0fd5a0 ç©ºåƒåœ¾è¢‹
```



# åŸå­æ•°ç»„

## å¸¸è§çš„åŸå­æ•°ç»„

- AtomicIntegerArray
- AtomicLongArray
- AtomicReferenceArray

> åŸå­æ•°ç»„ï¼Œä»…èƒ½ä¿è¯è¯¥æ•°ç»„å†…å…ƒç´ çš„çº¿ç¨‹å®‰å…¨æ€§ã€‚



## æ¡ˆä¾‹

- æµ‹è¯•çº¿ç¨‹å®‰å…¨æ€§çš„æ–¹æ³•ï¼š

  ```java
  /**
   å‚æ•°1ï¼Œæä¾›æ•°ç»„ã€å¯ä»¥æ˜¯çº¿ç¨‹ä¸å®‰å…¨æ•°ç»„æˆ–çº¿ç¨‹å®‰å…¨æ•°ç»„
   å‚æ•°2ï¼Œè·å–æ•°ç»„é•¿åº¦çš„æ–¹æ³•
   å‚æ•°3ï¼Œè‡ªå¢æ–¹æ³•ï¼Œå›ä¼  array, index
   å‚æ•°4ï¼Œæ‰“å°æ•°ç»„çš„æ–¹æ³•
  */
  // supplier æä¾›è€… æ— ä¸­ç”Ÿæœ‰ ()->ç»“æœ
  // function å‡½æ•° ä¸€ä¸ªå‚æ•°ä¸€ä¸ªç»“æœ (å‚æ•°)->ç»“æœ , BiFunction (å‚æ•°1,å‚æ•°2)->ç»“æœ
  // consumer æ¶ˆè´¹è€… ä¸€ä¸ªå‚æ•°æ²¡ç»“æœ (å‚æ•°)->void, BiConsumer (å‚æ•°1,å‚æ•°2)->
  private static <T> void demo(
      Supplier<T> arraySupplier,
      Function<T, Integer> lengthFun,
      BiConsumer<T, Integer> putConsumer,
      Consumer<T> printConsumer ) {
      
      List<Thread> ts = new ArrayList<>();
      T array = arraySupplier.get();
      int length = lengthFun.apply(array);
      for (int i = 0; i < length; i++) {
          // æ¯ä¸ªçº¿ç¨‹å¯¹æ•°ç»„ä½œ 10000 æ¬¡æ“ä½œ
          ts.add(new Thread(() -> {
              for (int j = 0; j < 10000; j++) {
                  putConsumer.accept(array, j%length);
              }
          }));
      }
      
      ts.forEach(t -> t.start()); // å¯åŠ¨æ‰€æœ‰çº¿ç¨‹
      ts.forEach(t -> {
          try {
              t.join();
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
      }); // ç­‰æ‰€æœ‰çº¿ç¨‹ç»“æŸ
      printConsumer.accept(array);
  }
  ```

- éçº¿ç¨‹å®‰å…¨çš„æ•°ç»„ï¼š

  ```java
  demo(
      ()->new int[10],
      (array)->array.length,
      (array, index) -> array[index]++,
      array-> System.out.println(Arrays.toString(array))
  );
  ```

  ```
  [9870, 9862, 9774, 9697, 9683, 9678, 9679, 9668, 9680, 9698] 
  ```

- çº¿ç¨‹å®‰å…¨çš„æ•°ç»„ï¼š

  ```java
  demo(
      ()-> new AtomicIntegerArray(10),
      (array) -> array.length(),
      (array, index) -> array.getAndIncrement(index),
      array -> System.out.println(array)
  );
  ```

  ```
  [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000] 
  ```

  

# å­—æ®µæ›´æ–°å™¨

> åˆ©ç”¨å­—æ®µæ›´æ–°å™¨ï¼Œå¯ä»¥é’ˆå¯¹å¯¹è±¡çš„æŸä¸ªåŸŸï¼ˆFieldï¼‰è¿›è¡ŒåŸå­æ“ä½œï¼Œ**åªèƒ½é…åˆ volatile ä¿®é¥°çš„å­—æ®µä½¿ç”¨**ï¼Œå¦åˆ™ä¼šå‡ºç°å¼‚å¸¸ï¼š
>
> Exception in thread "main" java.lang.IllegalArgumentException: Must be volatile type

- AtomicReferenceFieldUpdater
- AtomicIntegerFieldUpdater
- AtomicLongFieldUpdater



```java
public class Test5 {
    private volatile int field;

    public static void main(String[] args) {
        AtomicIntegerFieldUpdater fieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Test5.class, "field");
        Test5 test5 = new Test5();

        fieldUpdater.compareAndSet(test5, 0, 10);
        System.out.println(test5.field);            // ä¿®æ”¹æˆåŠŸ field = 10

        fieldUpdater.compareAndSet(test5, 10, 20);
        System.out.println(test5.field);                // ä¿®æ”¹æˆåŠŸ field = 20

        fieldUpdater.compareAndSet(test5, 10, 30);
        System.out.println(test5.field);                // ä¿®æ”¹å¤±è´¥ field = 20
    }
}
```

> æ³¨æ„è¢«ä¿®æ”¹å­—æ®µçš„è®¿é—®æ§åˆ¶æƒé™



# åŸå­ç´¯åŠ å™¨

åœ¨JDK8ä»¥åï¼Œæ–°å¢äº†å‡ ä¸ªä¸“é—¨ç”¨äºç´¯åŠ çš„ç±»ï¼š

- `DoubleAccumulator`
- `DoubleAdder`
- `LongAccumulator`
- `LongAdder`

> ç›¸è¾ƒäºAtomicLongç­‰ï¼Œè¿™äº›ç´¯åŠ å™¨ç±»çš„æ•ˆç‡æ›´é«˜ã€‚



## ç´¯åŠ å™¨çš„æ€§èƒ½æ¯”è¾ƒ

```java
public class Test {

    private static <T> void demo(Supplier<T> adderSupplier, Consumer<T> action) {
        T adder = adderSupplier.get();
        long start = System.nanoTime();
        List<Thread> ts = new ArrayList<>();
        // 4 ä¸ªçº¿ç¨‹ï¼Œæ¯äººç´¯åŠ  50 ä¸‡
        for (int i = 0; i < 4; i++) {
            ts.add(new Thread(() -> {
                for (int j = 0; j < 500000; j++) {
                    action.accept(adder);
                }
            }));
        }
        ts.forEach(t -> t.start());
        ts.forEach(t -> {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        long end = System.nanoTime();
        System.out.println(adder + " cost:" + (end - start) / 1000_000);
    }

    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            demo(() -> new LongAdder(), adder -> adder.increment());
        }

        for (int i = 0; i < 5; i++) {
            demo(() -> new AtomicLong(), adder -> adder.getAndIncrement());
        }
    }
}
```

```
2000000 cost:20
2000000 cost:11
2000000 cost:2
2000000 cost:2
2000000 cost:2

2000000 cost:23
2000000 cost:18
2000000 cost:20
2000000 cost:19
2000000 cost:17
```



>æ€§èƒ½æå‡çš„åŸå› å¾ˆç®€å•ï¼Œå°±æ˜¯åœ¨æœ‰ç«äº‰æ—¶ï¼Œè®¾ç½®å¤šä¸ªç´¯åŠ å•å…ƒï¼ŒTherad-0 ç´¯åŠ  Cell[0]ï¼Œè€Œ Thread-1 ç´¯åŠ  Cell[1]... æœ€åå°†ç»“æœæ±‡æ€»ã€‚è¿™æ ·å®ƒä»¬åœ¨ç´¯åŠ æ—¶æ“ä½œçš„ä¸åŒçš„ Cell å˜é‡ï¼Œå› æ­¤å‡å°‘äº† CAS é‡è¯•å¤±è´¥ï¼Œä»è€Œæé«˜æ€§ èƒ½ã€‚



## CASé”

```java
// ä¸è¦ç”¨äºå®è·µï¼ï¼ï¼
public class LockCas {
    // 0è¡¨ç¤ºæœªåŠ é”ï¼›1è¡¨ç¤ºå·²åŠ é”
    private AtomicInteger state = new AtomicInteger(0);
    
    public void lock() {
        while (true) {
            if (state.compareAndSet(0, 1)) {
                break;
            }
        }
    }
    
    public void unlock() {
        log.debug("unlock...");
        state.set(0);
    }
}
```

> #### ğŸ’¡æ³¨æ„
>
> è¿™ç§å®ç°ï¼Œä¼šåœ¨åŠ é”å¤±è´¥æ—¶é‡å¤å°è¯•åŠ é”ï¼Œè€Œéä¸‹å¤„ç†æœºè¿›å…¥é˜»å¡ã€‚



æµ‹è¯•ï¼š

```java
LockCas lock = new LockCas();
new Thread(() -> {
    log.debug("begin...");
    lock.lock();
    try {
        log.debug("lock...");
        sleep(1);
    } finally {
        lock.unlock();
    }
}).start();

new Thread(() -> {
    log.debug("begin...");
    lock.lock();
    try {
        log.debug("lock...");
    } finally {
        lock.unlock();
    }
}).start();
```



## LongAdderæºç 

[è§†é¢‘è®²è§£](https://www.bilibili.com/video/BV16J411h7Rd?p=179)



LongAdder ç±»æœ‰å‡ ä¸ªå…³é”®åŸŸï¼š

```java
// ç´¯åŠ å•å…ƒæ•°ç»„, æ‡’æƒ°åˆå§‹åŒ–
transient volatile Cell[] cells;

// åŸºç¡€å€¼, å¦‚æœæ²¡æœ‰ç«äº‰, åˆ™ç”¨ cas ç´¯åŠ è¿™ä¸ªåŸŸ
transient volatile long base;

// åœ¨ cells åˆ›å»ºæˆ–æ‰©å®¹æ—¶, ç½®ä¸º 1, è¡¨ç¤ºåŠ é”
transient volatile int cellsBusy;
```



### åŸç†ä¹‹ä¼ªå…±äº«

å…¶ä¸­ Cell å³ä¸ºç´¯åŠ å•å…ƒ

```java
@sun.misc.Contended	// é˜²æ­¢ç¼“å­˜è¡Œ ä¼ªå…±äº«
static final class Cell {
    volatile long value;
    Cell(long x) { value = x; }

    // æœ€é‡è¦çš„æ–¹æ³•, ç”¨æ¥ cas æ–¹å¼è¿›è¡Œç´¯åŠ , prev è¡¨ç¤ºæ—§å€¼, next è¡¨ç¤ºæ–°å€¼
    final boolean cas(long prev, long next) {
        return UNSAFE.compareAndSwapLong(this, valueOffset, prev, next);
    }
    // çœç•¥ä¸é‡è¦ä»£ç 
}
```



- ç¼“å­˜ä»¥ç¼“å­˜è¡Œä¸ºå•ä½ï¼Œæ¯ä¸ªç¼“å­˜è¡Œå¯¹åº”ç€ä¸€å—å†…å­˜ï¼Œä¸€èˆ¬æ˜¯ 64 byteï¼ˆ8 ä¸ª longï¼‰
- ç¼“å­˜çš„åŠ å…¥ä¼šé€ æˆæ•°æ®å‰¯æœ¬çš„äº§ç”Ÿï¼Œå³åŒä¸€ä»½æ•°æ®ä¼šç¼“å­˜åœ¨ä¸åŒæ ¸å¿ƒçš„ç¼“å­˜è¡Œä¸­ã€‚
- CPU è¦ä¿è¯æ•°æ®çš„ä¸€è‡´æ€§ï¼Œå¦‚æœæŸä¸ª CPU æ ¸å¿ƒæ›´æ”¹äº†æ•°æ®ï¼Œå…¶å®ƒ CPU æ ¸å¿ƒå¯¹åº”çš„æ•´ä¸ªç¼“å­˜è¡Œå¿…é¡»å¤±æ•ˆã€‚



![image-20220519172823522](%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%97%A0%E9%94%81.assets/image-20220519172823522.png)

å› ä¸º Cell æ˜¯æ•°ç»„å½¢å¼ï¼Œåœ¨å†…å­˜ä¸­æ˜¯è¿ç»­å­˜å‚¨çš„ï¼Œä¸€ä¸ª Cell ä¸º 24 å­—èŠ‚ï¼ˆ16 å­—èŠ‚çš„å¯¹è±¡å¤´å’Œ 8 å­—èŠ‚çš„ valueï¼‰ï¼Œå›  æ­¤ç¼“å­˜è¡Œå¯ä»¥å­˜ä¸‹ 2 ä¸ªçš„ Cell å¯¹è±¡ã€‚

å¦‚æœæ­¤æ—¶ï¼š

- Core-0 è¦ä¿®æ”¹ Cell[0]
- Core-1 è¦ä¿®æ”¹ Cell[1]

æ— è®ºè°ä¿®æ”¹æˆåŠŸï¼Œéƒ½ä¼šå¯¼è‡´å¯¹æ–¹ Core çš„ç¼“å­˜è¡Œå¤±æ•ˆï¼Œæ¯”å¦‚ Core-0 ä¸­ Cell[0]=6000, Cell[1]=8000 è¦ç´¯åŠ  Cell[0]=6001, Cell[1]=8000 ï¼Œè¿™æ—¶ä¼šè®© Core-1 çš„ç¼“å­˜è¡Œå¤±æ•ˆã€‚

> è¿™ç§ç°è±¡ï¼Œå³ä¸ºä¼ªå…±äº«ã€‚



`@sun.misc.Contended` ç”¨æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå®ƒçš„åŸç†æ˜¯**åœ¨ä½¿ç”¨æ­¤æ³¨è§£çš„å¯¹è±¡æˆ–å­—æ®µçš„å‰åå„å¢åŠ  128 å­—èŠ‚å¤§å°çš„ padding**ï¼Œä»è€Œ**è®© CPU å°†å¯¹è±¡é¢„è¯»è‡³ç¼“å­˜æ—¶å ç”¨ä¸åŒçš„ç¼“å­˜è¡Œ**ï¼Œè¿™æ ·ï¼Œä¸ä¼šé€ æˆå¯¹æ–¹ç¼“å­˜è¡Œçš„å¤±æ•ˆã€‚

![image-20220519172959559](%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%97%A0%E9%94%81.assets/image-20220519172959559.png)



### addæ–¹æ³•

```java
public void add(long x) {
    // as ä¸ºç´¯åŠ å•å…ƒæ•°ç»„
    // b ä¸ºåŸºç¡€å€¼
    // x ä¸ºç´¯åŠ å€¼
    Cell[] as; long b, v; int m; Cell a;
    
    // è¿›å…¥ if çš„ä¸¤ä¸ªæ¡ä»¶
    // 1. as æœ‰å€¼, è¡¨ç¤ºå·²ç»å‘ç”Ÿè¿‡ç«äº‰, è¿›å…¥ if
    // 2. cas ç»™ base ç´¯åŠ æ—¶å¤±è´¥äº†, è¡¨ç¤º base å‘ç”Ÿäº†ç«äº‰, è¿›å…¥ if
    if ((as = cells) != null || !casBase(b = base, b + x)) {
        // uncontended è¡¨ç¤º cell æ²¡æœ‰ç«äº‰
        boolean uncontended = true;
        if (
            // as è¿˜æ²¡æœ‰åˆ›å»º
            as == null || (m = as.length - 1) < 0 ||
            // å½“å‰çº¿ç¨‹å¯¹åº”çš„ cell è¿˜æ²¡æœ‰
            (a = as[getProbe() & m]) == null ||
            // cas ç»™å½“å‰çº¿ç¨‹çš„ cell ç´¯åŠ å¤±è´¥ uncontended=false ( a ä¸ºå½“å‰çº¿ç¨‹çš„ cell )
            !(uncontended = a.cas(v = a.value, v + x))
        ) {
            // è¿›å…¥ cell æ•°ç»„åˆ›å»ºã€cell åˆ›å»ºçš„æµç¨‹
            longAccumulate(x, null, uncontended);
        }
    }
}
```

![image-20220519173242470](%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%97%A0%E9%94%81.assets/image-20220519173242470.png)



```java
final void longAccumulate(long x, LongBinaryOperator fn,
                          boolean wasUncontended) {
    int h;
    // å½“å‰çº¿ç¨‹è¿˜æ²¡æœ‰å¯¹åº”çš„ cell, éœ€è¦éšæœºç”Ÿæˆä¸€ä¸ª h å€¼ç”¨æ¥å°†å½“å‰çº¿ç¨‹ç»‘å®šåˆ° cell
    if ((h = getProbe()) == 0) {
        // åˆå§‹åŒ– probe
        ThreadLocalRandom.current();
        // h å¯¹åº”æ–°çš„ probe å€¼, ç”¨æ¥å¯¹åº” cell
        h = getProbe();
        wasUncontended = true;
    }
    // collide ä¸º true è¡¨ç¤ºéœ€è¦æ‰©å®¹
    boolean collide = false; 
    for (;;) {
        Cell[] as; Cell a; int n; long v;
        // å·²ç»æœ‰äº† cells
        if ((as = cells) != null && (n = as.length) > 0) {
            // è¿˜æ²¡æœ‰ cell
            if ((a = as[(n - 1) & h]) == null) {
                // ä¸º cellsBusy åŠ é”, åˆ›å»º cell, cell çš„åˆå§‹ç´¯åŠ å€¼ä¸º x
                // æˆåŠŸåˆ™ break, å¦åˆ™ç»§ç»­ continue å¾ªç¯
            }
            // æœ‰ç«äº‰, æ”¹å˜çº¿ç¨‹å¯¹åº”çš„ cell æ¥é‡è¯• cas
            else if (!wasUncontended)
                wasUncontended = true;
            // cas å°è¯•ç´¯åŠ , fn é…åˆ LongAccumulator ä¸ä¸º null, é…åˆ LongAdder ä¸º null
            else if (a.cas(v = a.value, ((fn == null) ? v + x : fn.applyAsLong(v, x))))
                break;
            // å¦‚æœ cells é•¿åº¦å·²ç»è¶…è¿‡äº†æœ€å¤§é•¿åº¦, æˆ–è€…å·²ç»æ‰©å®¹, æ”¹å˜çº¿ç¨‹å¯¹åº”çš„ cell æ¥é‡è¯• cas
            else if (n >= NCPU || cells != as)
                collide = false;
            // ç¡®ä¿ collide ä¸º false è¿›å…¥æ­¤åˆ†æ”¯, å°±ä¸ä¼šè¿›å…¥ä¸‹é¢çš„ else if è¿›è¡Œæ‰©å®¹äº†
            else if (!collide)
                collide = true;
            // åŠ é”
            else if (cellsBusy == 0 && casCellsBusy()) {
                // åŠ é”æˆåŠŸ, æ‰©å®¹
                continue;
            }
            // æ”¹å˜çº¿ç¨‹å¯¹åº”çš„ cell
            h = advanceProbe(h);
        }
        // è¿˜æ²¡æœ‰ cells, å°è¯•ç»™ cellsBusy åŠ é”
        else if (cellsBusy == 0 && cells == as && casCellsBusy()) {
            // åŠ é”æˆåŠŸ, åˆå§‹åŒ– cells, æœ€å¼€å§‹é•¿åº¦ä¸º 2, å¹¶å¡«å……ä¸€ä¸ª cell
            // æˆåŠŸåˆ™ break;
        }
        // ä¸Šä¸¤ç§æƒ…å†µå¤±è´¥, å°è¯•ç»™ base ç´¯åŠ 
        else if (casBase(v = base, ((fn == null) ? v + x : fn.applyAsLong(v, x))))
            break;
    }
}
```

![image-20220519173712307](%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%97%A0%E9%94%81.assets/image-20220519173712307.png)

![image-20220519174045411](%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%97%A0%E9%94%81.assets/image-20220519174045411.png)

![image-20220519174105556](%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%97%A0%E9%94%81.assets/image-20220519174105556.png)



### sumæ–¹æ³•

è·å–æœ€ç»ˆç»“æœé€šè¿‡ sum æ–¹æ³•

```java
public long sum() {
    Cell[] as = cells; Cell a;
    long sum = base;
    if (as != null) {
        for (int i = 0; i < as.length; ++i) {
            if ((a = as[i]) != null)
                sum += a.value;
        }
    }
    return sum;
}
```



# Unsafeç±»

## è·å–UnSafeå¯¹è±¡

Unsafe å¯¹è±¡æä¾›äº†éå¸¸åº•å±‚çš„ï¼Œæ“ä½œå†…å­˜ã€çº¿ç¨‹çš„æ–¹æ³•ï¼ŒUnsafe å¯¹è±¡ä¸èƒ½ç›´æ¥è°ƒç”¨ï¼Œåªèƒ½é€šè¿‡åå°„è·å¾—ï¼š

æµ‹è¯•ç±»å¦‚ä¸‹ï¼š

```java
public class UnsafeAccessor {
    static Unsafe unsafe;
    static {
        try { 
            Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
            theUnsafe.setAccessible(true);
            unsafe = (Unsafe) theUnsafe.get(null);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            throw new Error(e);
        }
    }
    static Unsafe getUnsafe() {
        return unsafe;
    }
}
```



## Unsafeçš„åº•å±‚CAS

```java
@Data
class Student {
    volatile int id;
    volatile String name;
}
```



æµ‹è¯•ä»£ç å¦‚ä¸‹ï¼š

```java
Unsafe unsafe = UnsafeAccessor.getUnsafe();
Field id = Student.class.getDeclaredField("id");
Field name = Student.class.getDeclaredField("name");

// è·å¾—æˆå‘˜å˜é‡çš„åç§»åœ°å€
long idOffset = UnsafeAccessor.unsafe.objectFieldOffset(id);
long nameOffset = UnsafeAccessor.unsafe.objectFieldOffset(name);

Student student = new Student();
// ä½¿ç”¨ cas æ–¹æ³•æ›¿æ¢æˆå‘˜å˜é‡çš„å€¼
UnsafeAccessor.unsafe.compareAndSwapInt(student, idOffset, 0, 20); // è¿”å› true
UnsafeAccessor.unsafe.compareAndSwapObject(student, nameOffset, null, "å¼ ä¸‰"); // è¿”å› true
System.out.println(student);
```



## è‡ªå®šä¹‰å®ç°çš„AtomicInteger

```java
class MyAtomicInteger {
    private static final Unsafe UNSAFE;
    private static long valueOffset;

    private volatile int value;


    static {
        UNSAFE = UnsafeAccessor.getUnsafe();
        try {
            valueOffset = UNSAFE.objectFieldOffset(MyAtomicInteger.class.getDeclaredField("value"));
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        }
    }

    public int getValue() {
        return this.value;
    }

    public boolean compareAndSetValue(int expected, int next) {

        return UNSAFE.compareAndSwapInt(this, valueOffset, expected, next);
    }

    public void decrement() {
        while (true) {
            int prev = this.value;

            if (this.compareAndSetValue(prev, prev - 1))
                return;
        }
    }

    public static void main(String[] args) throws InterruptedException {
        MyAtomicInteger atomicInteger = new MyAtomicInteger();
        atomicInteger.value = 1000;

        ArrayList<Thread> threads = new ArrayList<>();

        for (int i = 0; i < 20; i++) {
            threads.add(new Thread(() -> {
                for (int j = 0; j < 20; j++) {
                    atomicInteger.decrement();
                }
            }));
        }

        threads.forEach(thread -> thread.start());
        threads.forEach(thread -> {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        System.out.println(atomicInteger.value);
    }
}
```


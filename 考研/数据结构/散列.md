# 散列的核心

- 散列函数
- 冲突解决



# 冲突的解决

## 分离链接法

![image-20221009175325753](%E6%95%A3%E5%88%97.assets/image-20221009175325753.png)



- 装填因子：$\lambda= \frac{已存入元素个数n}{哈希表大小m}$

  装填因子越小，越不容易碰撞。



## 开放定址法

思路：

- 额外尝试另外一些单元$h_o(x),h_1(x),\cdots$，直到找到空的单元为止。

  其中：$h_i(x)=(hash(x)+f(i))\mod TableSize$



### 线性探测法

- 即$f(i)=i$。
- 会导致“一次聚集”现象。

- 当表有一半元素被填满时，就不再是一个好的解决方案。



### 平方探测法

- 即$f(i)=i^2$。
- 如果表有一半是空的，且表的大小为素数，则总能保证插入一个新的元素。
- 会导致“二次聚集”现象。





### 双散列

- $f(i)= i * hash(x)$

  即再使用一个hash函数，每次移动$hash(x)$远。

- 比较好的选择：$hash(x)=R-(x\mod R)$，$R$是一个小于tablesize的素数。







## （重新）再散列

当原有散列表填充的过满时，新建一个更大的散列表，同时选择一个新的散列函数，将原表中的元素，散列到新表中。



三种策略：

- 表满一半，再散列。
- 插入失败，再散列。
- ==途中散列==：装填因子达到阈值，再散列。
# 数学基础

## 四个记号的定义

用于建立**函数间相对级别**（比较的是相对增长率）的记号：

- 如果存在正常数$$c$$和$$n_0$$，使得当$$N\geq n_0$$时有$$T(N)\leq cf(N)$$，则记作==$$T(N)=O(f(N))$$==。

  > 说明$$T(N)$$的增长率，小于等于$$f(N)$$。

- 如果存在正常数$$c$$和$$n_0$$，使得当$$N\geq n_0$$时有$$T(N)\geq cf(N)$$，则记作==$$T(N)=\Omega (f(N))$$==。

  > 说明$$T(N)$$的增长率，大于等于$$f(N)$$。

- ==$$T(N)=\Theta(h(N))$$==，当且仅当$$T(N)=O(f(N))$$和$$T(N)=\Omega (f(N))$$。

  >说明$$T(N)$$的增长率，等于$$f(N)$$。

- 如果对每一个正常数$$c$$，都存在常数$$n_0$$，使得当$$N\ge n_0$$时$$T(N)\le cp(N)$$，则==$$T(N)=o(p(N))$$==。

  或者说，如果$$T(N)=O(p(N))$$且$$T(N)\neq \Theta(p(N))$$，则$$T(N)=o(p(N))$$。

  >说明$$T(N)$$的增长率，大于$$p(N)$$。



需要注意一点，在需要大O表示的任何分析中，要求的精度是很粗糙的。这意味着==应该丢掉低阶项和常数项==。



## 重要结论

1. 如果$$T_1(N)=O(f(N))$$且$$T_2(N)=O(g(N))$$，那么：

   - $$T_1(N) + T_2(N) =O(f(N)+g(N))$$

   - $$T_1(N) * T_2(N) = O(f(N)*g(N))$$

2. 如果$$T(N)$$是一个$$k$$次多项式，那么$$T(N)=\Theta(N^k)$$。
3. 对于任意常数k，$$log^kN=O(N)$$。



事实上，对于任意的两个函数$f(N)$和$g(N)$，可以通过计算极限$${\lim\limits_{N\to\infty}\frac{f(N)}{g(N)}}$$来确定。该极限的四种可能取值：

|   取值   |             意义             |
| :------: | :--------------------------: |
|   $0$    |        $f(N)=o(g(N))$        |
| $c\neq0$ |     $f(N)=\Theta(g(N))$      |
| $\infty$ |        $g(N)=o(f(N))$        |
| 极限摆动 | 二者无关（本书不出现此情形） |



# 模型

做如下假设：

- 我们的模型基本上为一台标准计算机，在该机器中，==指令顺序被执行==。
- 有一个简单的指令系统，做任何一件简单的工作（如加减乘除），都==恰好花费一个时间单位==。
- ==内存无限==。



# 运行时间估计

> 为简化分析，做如下约定：
>
> - 不存在特定的时间单位。
> - 计算大O运行时间。（抛弃常数项、抛弃低阶项）



一般法则（或者说用于评估的技巧）：

- 对于for循环：

  时间开销 = 循环体（与每次测试）的运行时间 * 迭代次数。

- 嵌套for循环：由里向外分析。

- 顺序语句：依次求和。

- if/else语句：判断时间 + 分支取最大值。



# Example-最大子序列和

## $O(n^3)$解法

![image-20220812133629205](%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.assets/image-20220812133629205.png)



## $O(n^2)$解法

![image-20220812133852269](%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.assets/image-20220812133852269.png)



## $O(NlogN)$解法

> 基于递归分治。

![image-20220812144317348](%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.assets/image-20220812144317348.png)





```java
import static java.lang.Math.max;

public class Solution {

    private static int maxSumRec(int[] a, int left, int right) {
        if (left == right) {
            return max(a[left], 0);
        }

        int center = (left + right) / 2;
        int maxLeftSum = maxSumRec(a, left, center);
        int maxRightSum = maxSumRec(a, center + 1, right);

        int maxLeftBorderSum = 0, leftBorderSum = 0;
        for (int i = center; i >= left; i--) {
            leftBorderSum += a[i];
            if (leftBorderSum > maxLeftBorderSum)
                maxLeftBorderSum = leftBorderSum;
        }

        int maxRightBorderSum = 0, rightBorderSum = 0;
        for (int i = center + 1; i <= right; i++) {
            rightBorderSum += a[i];
            if (rightBorderSum > maxRightBorderSum)
                maxRightBorderSum = rightBorderSum;
        }

        return max(max(maxLeftSum, maxRightSum),
                maxLeftBorderSum + maxRightBorderSum);
    }

    public static int maxSubSum3(int[] a) {
        return maxSumRec(a, 0, a.length - 1);
    }

    public static void main(String[] args) {
        int[] a  = {4,-3,5,-2,-1,2,6,-2};
        int res = maxSubSum3(a);
        System.out.println(res);
    }
}
```



## $O(N)$解法

![image-20220812144555015](%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.assets/image-20220812144555015.png)




# 基本概念

- ==各个组件或设备，在linux下都是一个文件==。



# 各硬件设备在Linux下的文件名

![image-20220911145212559](%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA.assets/image-20220911145212559.png)





# 磁盘连接方式与设备文件名的关系

![image-20220911145818450](%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA.assets/image-20220911145818450.png)





# MBR和GPT磁盘分区表

磁盘盘片示意图：

![image-20220911145913590](%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA.assets/image-20220911145913590.png)

> 其中扇区的物理大小设计有两种：512B和4KB。



## MBR

磁盘的第一个扇区（512B）会有如下两个东西：

- 主引导记录（MBR）：可以安装启动引导程序的地方，有446字节。
- 分区表（partition table）：记录整块硬盘分区的状态，有64字节。



由于分区表所在区别仅有64字节，因此最多仅能有四组记录区，==每组记录区记录了该区段的起始和结束的柱面号码==。



例如：假设一硬盘设备/dev/sda，那么它的四个分区，在linux系统中的设备文件名如下：

1. P1：/dev/sda1
2. P2：/dev/sda2
3. P3：/dev/sda3
4. P4：/dev/sda4

![image-20220911150623130](%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA.assets/image-20220911150623130.png)



> 在上图中，将硬盘以长条形来看，将柱面以柱形图来看，并假设硬盘只有400个柱面。

> 若操作系统为Windows，则上面四个分区的代号即为C、D、E、F。



结论：

1. 所谓的分区，就是对该64字节的分区表进行设置。
2. 硬盘默认的分区表，仅能写入四组分区信息。
3. 这四组划分信息，称为主要或拓展分区。
4. ==分区的最小单位是柱面==。
5. 当系统要写入磁盘时，一定会参杂磁盘分区表，才能针对某个分区进行数据的处理。



## MBR的逻辑分区

虽然MBR的分区表只有记录四组数据的空间，但可以将一块硬盘划分为多于四个分区。



![image-20220911151358725](%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA.assets/image-20220911151358725.png)

在该图中，硬盘的四个分区记录区仅使用两个：

1. P1作为主要分区；

2. P2作为扩展分区。

   > 扩展分区的目的是使用额外的扇区来记录分区信息，扩展分区本身并不能被拿来格式化。

   由拓展分区划分出来的分区，就被称为==逻辑分区==。



在Linux系统中，上述分区的设备名分别是：

- P1：/dev/sda1
- P2：/dev/sda2
- L1：/dev/sda5
- L2：/dev/sda6
- L3：/dev/sda7
- L4：/dev/sda8
- L5：/dev/sda9

> - 即设备名/dev/sda3和/dev/sda4没被使用。
> - ==拓展分区P2（/dev/sda2），包含了5个逻辑分区==。

==前四个号码是保留给主要分区或拓展分区用的，逻辑分区的设备名称号码从5开始==。



MBR的主要分区、拓展分区、逻辑分区总结：

1. 主要分区和拓展分区只能有4个（硬盘限制）。
2. 拓展分区只能有1个（操作系统限制）。
3. 逻辑分区是由拓展分区划分的。
4. 能被格式化后作为数据存储的分区，只能是主要分区和逻辑分区，拓展分区不能格式化。
5. 逻辑分区的数量取决于操作系统，在Linux系统中SATA硬盘可以突破63个以上的限制。



## MBR的限制

1. 操作系统无法使用2.2TB以上的磁盘容量。
2. MBR仅有一个区块，被破坏后，很难修复。
3. MBR内存放启动引导程序的区块仅446字节，无法存储较多的程序代码。



## GPT磁盘分区表

> 即GUID partition table。



由于目前同时存在512B和4KB的扇区大小，为了兼容所有的硬盘，采用逻辑区别地址（Logical Block Address，LBA）。==GPT将磁盘所有区块依此LBA（默认512B）来规划，第一个LBA称为LBA0==。

![image-20220911153421617](%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA.assets/image-20220911153421617.png)

- LBA0（MBR兼容区块）：

  存放两个部分：

  1. 启动引导程序
  2. 特殊标识符，用于说明此硬盘为GPT格式。

- LBA1（GPT表头记录）：

  - 记录了分区表本身的位置和大小
  - 同时记录了备用的GPT分区表（最后34个LBA区块）放置的位置。
  - 以及分区表的CRC32校验码。

- LBA2~33（实际记录分区信息处）：

  每个LBA都可以记录4组分区记录（每组记录占128B）。

  ==每组分区记录的组成：用于记录开始/结束扇区的扇区号码（各64位）==。

  > 因此，GPT分区的单一分区，可以记录的最大容量为$2^{64}*512$B，即$2^{30}$TB。



GPT分区，没有了所谓的主、拓展、逻辑分区的概念，每组分区可以单独存在，每一个分区都可以单独拿来格式化。



## 总结

- MBR分区下，硬盘的组成：
  - 分区记录表（第一扇区的64字节，一项16字节。）
  - 主分区
  - 拓展分区：其又由逻辑分区组成。
- 只能对主分区和逻辑分区进行格式化。
- 逻辑分区的编号从5开始。



- GPT分区下，硬盘的组成：
  - LBA0
  - LBA1
  - LBA2~33
  - 剩余空间
  - LBA34~1（备用）

- 每个LBA（512B或4KB，通常512B），可以记录4个分区记录（128B）。
- ==一个分区记录，由各64B的扇区开始、结束号码组成==。



- 不是所有操作系统都能读取到GPT的硬盘分区格式；

- 不是所有硬件都支持GPT；

- 是否能够读写GPT格式，与启动的检测程序有关。

  > 启动的检测程序分为BIOS和UEFI。





# 启动流程中的BIOS或UEFI启动检测程序

基本上，目前的主机系统在加载硬件驱动程序方面的程序，主要有两种机制：

- 早期的BIOS
- 新的UEFI



## BIOS搭配MBR/GPT启动的流程

2.2.3节



## UEFI搭配GPT启动的流程

2.2.3节



# 目录树结构

例如：

![image-20220911162555994](%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA.assets/image-20220911162555994.png)



## 文件系统与目录树的关系（即挂载）

>- Linux系统内，使用的是目录树结构；
>- 但文件数据，实际上是放置在磁盘分区中。



所谓==挂载==，就是利用一个目录当成进入点，将磁盘分区的数据放置在该目录下；也就说说，==进入该目录就可以读取该分区==的意思。



![image-20220911162827327](%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA.assets/image-20220911162827327.png)

在该例子中：

硬盘被分为两个分区：

- 分区1被挂载到根目录；
- 分区2被挂载到/home目录下。

也就是说，放置到/home内的各层目录下的文件，其数据被放置到分区2中。



> 最简单的划分：
>
> - 根目录（/）
> - 交换分区（swap）
>
> 容量大，且读写频繁的目录：
>
> - /boot
> - /
> - /home
> - /var
> - swap
















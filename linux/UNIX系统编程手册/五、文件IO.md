# 原子操作和竞争条件

- 创建文件：
  - 会产生竞争条件的做法：先检查文件是否存在，再创建文件
  - 原子的做法：同时指定 O_EXCL 与 O_CREAT 作为 open()的标志位
- 追加写：
  - 竞争条件的做法：（未设置APPEND标志下）先lseek()，再写入
  - 原子的做法：在打开文件时加入 O_APPEND 标志，将文件偏移量的移动与数据写操作纳入同一原子操作。



# fcntl()文件控制操作

fcntl()系统调用对一个打开的文件描述符执行一系列控制操作。

![image-20221023204052176](%E4%BA%94%E3%80%81%E6%96%87%E4%BB%B6IO.assets/image-20221023204052176.png)



cmd 参数所支持的操作范围很广。

fcntl()的第三个参数以省略号来表示，这意味着可以将其设置为不同的类型，或者加以省略。内核会依据 cmd 参数（如果有的话）的值来确定该参数的数据类型。



## 读或修改状态标志

- 设置cmd参数为`F_GETFL`，以读取flag参数：

  ```cpp
  int flags = fcntl(fd, F_GETFL);
  // maybe error here, check out errno
  
  if (flags & O_SYNC)
      cout << "writes are synchronized";
  ```

- 判断文件的访问模式，需要先与`O_ACCMODE`进行与运算：

  > 因为常量`O_RDONLY(0)`,`O_WRONLY(1)`,`O_RWDR(2)`并不对应于单个比特位。

  ```cpp
  int acessMode = flags & O_ACCMODE;
  if (acessMode == O_WRONLY || accessMode == O_RDWR)
      cout << "file is writable";
  ```

- 修改状态标志：

  - 设置cmd参数为`F_SETFL`，可以修改***==部分==***状态标志（`O_APPEND`,`O_NONBLOCK`,`O_NOATIME`,`O_ASYNC`,`O_DIRECT`），其余标志的修改将被系统忽略。

  - ==适用的场景：文件并非通过open()打开==，例如：

    - 文件不是由调用程序打开的，所以程序也无法使用 open()调用来控制文件的状态标志（例如，文件是 3 个标准输入输出描述符中的一员，这些描述符在程序启动之前就被打开）。
    - 文件描述符的获取是通过 open()之外的系统调用。比如 pipe()调用，该调用创建一个管道，并返回两个文件描述符分别对应管道的两端。再比如 socket()调用，该调用创建一个套接字并返回指向该套接字的文件描述符。

  - 例如，添加`O_APPEND`标志的示例如下：

    ```cpp
    int flags = fcntl(fd, F_GETFL);
    if (flags == -1)
        process_error();
    
    flags |= O_APPEND;
    if(fcntl(fd, F_SETFL, flags) == -1)
        process_error();
    ```

    

# 文件描述符和打开文件之间的关系

- 在通常情况下，FD与打开的文件是一一对应的。

- 但允许：多个FD，指向同一个文件。

  > 这些FD，既可以在同一进程，也可在不同进程。

  



内核维护了3个数据结构：

- ==***进程级***的文件描述符表==：用户描述每个进程打开了哪些文件。每一条目用于记录单个文件描述符的信息，包含：

  - 控制文件描述符操作的一组标志（仅close-on-exec标志）。
  - 对打开文件句柄的引用。

- ==***系统级***的打开文件表==：每一条目用于记录打开文件的信息，包含：

  > 每个条目称为***==打开文件句柄==(open file handle)***。

  - 当前文件偏移量（调用 read()和 write()时更新，或使用 lseek()直接修改）。
  - 打开文件时所使用的状态标志（即，open()的 flags 参数）。
  - 文件访问模式（如调用 open()时所设置的只读模式、只写模式或读写模式）。
  - 与信号驱动 I/O 相关的设置。
  - 对该文件 i-node 对象的引用。

- ==***文件系统***的 i-node 表==：

  > - 文件系统上的一个文件，对应一个i-node对象。
  > - 此处忽略i-node在磁盘和内存中的表示差异。当访问一个文件时，会在内存中创建i-node的副本，记录打开文件句柄数量。

  - 文件类型（例如，常规文件、套接字或 FIFO）和访问权限。
  - 一个指针，指向该文件所持有的锁的列表。
  - 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳。

![image-20221023210926118](%E4%BA%94%E3%80%81%E6%96%87%E4%BB%B6IO.assets/image-20221023210926118.png)

>- 在进程 A 中，文件描述符 1 和 20 都指向同一个打开的文件句柄（标号为 23）。这可能是通过调用 dup()、dup2()或 fcntl()而形成的（参见 5.5 节）。
>
>- 进程A的文件描述符2和进程B的文件描述符2都指向同一个打开的文件句柄（标号为73）。这种情形可能在调用 fork()后出现（即，进程 A 与进程 B 之间是父子关系），或者当某进程通过UNIX 域套接字将一个打开的文件描述符传递给另一进程时，也会发生（参见 61.13.3 节）。
>
>- 此外，进程 A 的描述符 0 和进程 B 的描述符 3 分别指向不同的打开文件句柄，但这些句柄均指向 i-node 表中的相同条目（1976），换言之，指向同一文件。**发生这种情况是因为每个进程各自对同一文件发起了 open()调用。同一个进程两次打开同一文件，也会发生类似情况**。



重点：

1. 两个不同的文件描述符，若指向同一打开文件句柄，将共享同一文件偏移量。

   >若一个FD修改了文件偏移量，无论这两个文件描述符分属于不同进程，还是同属于一个进程，另一个FD将会观察到变化。

2. 获取和修改打开的文件标志的规律同上。

3. 仅close-on-exec标志为进程和文件描述符所私有。

> [4-文件描述符与打开的文件之间的关系_songly_的博客-CSDN博客](https://blog.csdn.net/qq_35733751/article/details/80703923)



# 复制文件描述符

- dup()：

  dup()调用复制一个打开的文件描述符 oldfd，并返回一个新描述符，二者都指向同一打开的文件句柄。

  ![image-20221025164801357](%E4%BA%94%E3%80%81%E6%96%87%E4%BB%B6IO.assets/image-20221025164801357.png)

- dup2()：获得期望的文件描述符：

  ![image-20221025164845964](%E4%BA%94%E3%80%81%E6%96%87%E4%BB%B6IO.assets/image-20221025164845964.png)

  如果由 newfd 参数所指定编号的文件描述符之前已经打开，那么 dup2()会首先将其关闭。（dup2()调用会默然忽略 newfd 关闭期间出现的任何错误。故此，编码时更为安全的做法是：在调用dup2()之前，若 newfd 已经打开，则应显式调用 close()将其关闭。）

- fcntl()的 F_DUPFD 操作

- dup3()系统调用完成的工作与 dup2()相同，只是新增了一个附加参数 flag，这是一个可以修改系统调用行为的位掩码(只支持一个标志 O_CLOEXEC)。

- fcntl()用于复制文件描述符的附加命令：F_DUPFD_CLOEXEC。

  该标志不仅实现了与 F_DUPFD 相同的功能，还为新文件描述符设置 close-on-exec 标志。



# 在特定Offset处进行IO：pread(),pwrite()

系统调用 pread()和 pwrite()完成与 read()和 write()相类似的工作，只是前两者会在 offset 参数所指定的位置进行文件 I/O 操作，而非始于文件的当前偏移量处，且它们不会改变文件的当前偏移量。

![image-20221025165601806](%E4%BA%94%E3%80%81%E6%96%87%E4%BB%B6IO.assets/image-20221025165601806.png)



pread等同如下调用纳入原子操作：

![image-20221025165624836](%E4%BA%94%E3%80%81%E6%96%87%E4%BB%B6IO.assets/image-20221025165624836.png)



# 分散输入和集中输出：readv(),writev()

readv()和 writev()系统调用分别实现了分散输入和集中输出的功能。

![image-20221025172150184](%E4%BA%94%E3%80%81%E6%96%87%E4%BB%B6IO.assets/image-20221025172150184.png)

- 关于参数的说明：

  - iov为数组，iovcnt表面该数组的长度。

  - iovec结构体如下：

    ![image-20221025172517223](%E4%BA%94%E3%80%81%E6%96%87%E4%BB%B6IO.assets/image-20221025172517223.png)

- ==分散输入（将输入分散到多个Buffer）==：

  从文件描述符 fd 所指代的文件中读取一片连续的字节，然后将其散置（“分散放置”）于 iov 指定的缓冲区中。

- ==集中输出（将多个Buffer集中输出）==：

  将 iov 所指定的所有缓冲区中的数据拼接（“集中”）起来，然后以连续的字节序列写入文件描述符 fd 指代的文件中。

  



# preadv(),pwritev()

在指定的文件偏移量处执行分散输入/集中输出。



# 截断文件truncate()和 ftruncate()

truncate()和 ftruncate()系统调用将文件大小设置为 length 参数指定的值。

![image-20221025174916440](%E4%BA%94%E3%80%81%E6%96%87%E4%BB%B6IO.assets/image-20221025174916440.png)

若文件当前长度大于参数 length，调用将丢弃超出部分，若小于参数 length，调用将在文件尾部添加一系列空字节或是一个文件空洞。



# ==非阻塞I/O==

在打开文件时指定 O_NONBLOCK 标志，目的有二。

- 若 open()调用未能立即打开文件，则返回错误，而非陷入阻塞。
- 调用 open()成功后，后续的 I/O 操作也是非阻塞的。若 I/O 系统调用未能立即完成，则可能会只传输部分数据，或者系统调用失败，并返回 EAGAIN 或EWOULDBLOCK 错误。具体返回何种错误将依赖于系统调用。Linux 系统与许多 UNIX 实现一样，将两个错误常量视为同义。



- ==管道、FIFO、套接字、设备（比如终端、伪终端）都支持非阻塞模式==。
- 由于内核缓冲区保证了普通文件 I/O 不会陷入阻塞，故而打开普通文件时一般会忽略 O_NONBLOCK 标志。然而，当使用强制文件锁时（55.4 节），O_NONBLOCK标志对普通文件也是起作用的。



# 大文件I/O

通常将存放文件偏移量的数据类型 off_t 实现为一个有符号的长整型。（之所以采用有符号数据类型，是要以−1 来表示错误情况。）==在 32 位体系架构中（比如 x86-32），这将文件大小置于 231−1 个字节（即 2GB）的限制之下==。



# /dev/fd目录

对于每个进程，内核都提供有一个特殊的虚拟目录/dev/fd。该目录中包含“/dev/fd/n”形式的文件名，其中 n 是与进程中的打开文件描述符相对应的编号。
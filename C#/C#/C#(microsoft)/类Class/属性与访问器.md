# Basic



```cs
namespace Test;


public class Stock
{
    public decimal currentPrice;   // (backing)field字段

    public decimal CurrentPrice // property属性
    {
        get { return currentPrice; }
        set { currentPrice = value; }
    }
}
class Program
{
    static void Main(string[] args)
    {
        Stock msft = new Stock();
        msft.CurrentPrice = 30;
        msft.CurrentPrice -= 3;

        Console.WriteLine(msft.CurrentPrice);   // 27

        msft.currentPrice = 10;
        Console.WriteLine(msft.CurrentPrice);   // 10
    }
}
```



- 从使用者的角度看：

  属性就是字段。

- 从内部实现的角度看：

  属性可以含有逻辑，与方法一样。



- <font color="red">属性一般对应着一个backing field</font>。

- 属性比backing field，多出set、get访问器：

  - get访问器：在属性被读取时运行

  - set访问器：在属性被赋值时运行。

    > 有一个隐式的该类型的参数`Value`。



# Expression-Bodied

```cs
public class Stock
{
    public decimal currentPrice;

    /*public decimal CurrentPrice
    {
        get { return currentPrice; }
        set { currentPrice = value; }
    }*/

    // setter C#6
    public decimal DoublePrice => currentPrice * 2;

    // C#7
    public decimal CurrentPrice
    {
        get => currentPrice;
        set => currentPrice = value;
    }
}
```



# 自动属性

```cs
public class Stock
{
    //public decimal CurrentPrice
    //{
    //    get { return _price; }
    //    private set { _price = value};
    //}

    
    public decimal CurrentPrice { get; private set; }
}
```

编译器会自动生成一个backing field。

> 但该backing field不可引用。



# 属性初始化器

```cs
public class Stock
{
    public decimal CurrentPrice
    {
        get;
        set;
    } = 123;

    // 可以在构造函数中被赋值
    public int Maximum { get; } = 999;
}
```

属性初始化器，用于设置初始值。

> 即便是只读的自动属性，可以在构造函数中赋值。



# 访问器的访问性

```cs
public class FOO{
    public int X{
        get;			// public
        private set;	// private
    }
}
```



# CLR的内部实现

```cs
public decimal CurrentPrice{ get; set; }
```

在编译器内部，会编译器为：
```cs
public decimal get_CurrentPrice(){...}
public void set_CurrentPrice(decimal value){...}
```



> 简单的非virtual属性的访问器，会被JIT编译器内联，从而消除访问属性和访问字段的性能差异。




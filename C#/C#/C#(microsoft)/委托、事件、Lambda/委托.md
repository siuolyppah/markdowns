- 委托是一个对象，它知道如何调用一个方法

  - 委托类型：

    定义了委托实例可以调用的方法（即定义了方法的返回类型和参数）。

  - 委托实例

    

```cs
class Program
{
    static string GetAMsg(int x)
    {
        return "he" + x;
    }

    // 委托类型
    delegate string Transformer(int x);

    static void Main(string[] args)
    {
        Transformer t = GetAMsg;    // 委托实例
        Console.WriteLine(t(20));
    }
}
```

> 实际上使用了简写：
> ```cs
> Transformer t = GetAMsg;
> // 等同于：
> Transformer t = new Transformer(GetAMsg);
> ```
>
> ```cs
> t(20);
> // 等同于：
> t.Invoke(3);
> ```





# 委托多播

- 一个委托实例，可以引用一组实例方法。
  - 增加委托：使用`+`和`+=`操作符
  - 移除委托：使用`-`和`-=`操作符

- 委托是不可变的。

  使用`+=`和`-=`时，实际上**创建了新的委托实例**。



- 关于返回值：
  - 返回最后一个调用的返回值。
  - 前面的方法返回值被忽略。

```cs
delegate int Transformer(int x);

class Program
{
    static int Square(int x) {
        var result = x * x;
        Console.WriteLine(result);
        return result;
    }

    static int Cube(int x) {
        var result = x * x * x;
        Console.WriteLine(result);
        return result; 
    }

    static void Main(string[] args)
    {
        Transformer t = null;
        t += Square;
        t += Cube;

        int result = t(3);
        Console.WriteLine(result);
    }
}
```





# 实例/静态方法目标

- 当一个实例方法被赋值给委托对象时，这个委托对象将保留：

  - 对这个方法的引用

  - 用`System.Delegate`的Target属性，保留这个实例。

    > 若引用的是静态方法，那么Target为null。



```cs
delegate int Transformer(int x);

class Program
{
    int Square(int x) => x * x;

    static void Main(string[] args)
    {
        Program program = new Program();
        Transformer t = program.Square;

        Console.WriteLine(program == t.Target); // true
    }
}
```



# 泛型委托

```cs
delegate T Transformer<T>(T arg);
```



System名称空间下：

![image-20220802154853581](%E5%A7%94%E6%89%98.assets/image-20220802154853581.png)





# 委托的兼容性

https://www.bilibili.com/video/BV1Ht41137R1?p=2&t=458.7








# 关于友元

- 声明一个普通函数为友元：

  ```cpp
  template<typename T>
  class Stack {
      void printOn() (std::ostream& strm) const {}
      
      friend std::ostream& operator<< (std::ostream& strm,
                                       Stack<T> const& s) {
          s.printOn(strm);
          return strm;
      }
  };
  ```

  >Note that this means that operator<< for class Stack<> is not a function template, but an “ordinary” function instantiated with the class template if needed.

- 声明一个模板函数，但提供别的模板参数：

  ```cpp
  template<typename T>
  class Stack {
  
      template<typename U>
      friend std::ostream& operator<< (std::ostream&, 
                                       Stack<U> const&);
  };
  ```

  > 在这种情况下，若模板参数名仍为T，他会隐藏外部的T。

- 利用前置声明，在类外进行声明（仍使用原先的模板参数）：

  ```cpp
  template<typename T>
  class Stack;
  
  template<typename T>
  std::ostream& operator<< (std::ostream&, Stack<T> const&);
  
  // declare the function as friend
  template<typename T>
  class Stack {
  
      friend std::ostream& operator<< <T> (std::ostream&,
                                           Stack<T> const&);
  };
  ```





# Specializations of Class Templates

```cpp
template<>
class Stack<std::string> {
...
};
```

For these specializations, any definition of a member function must be defined as an “ordinary” member function, with each occurrence of T being replaced by the specialized type.



# Partial Specialization

- original:

  ```cpp
  template<typename T1, typename T2>
  class MyClass {
  ...
  };
  ```

- partial:

  ```cpp
  // partial specialization: both template parameters have same type
  template<typename T>
  class MyClass<T,T> {
  ...
  };
  
  // partial specialization: second type is int
  template<typename T>
  class MyClass<T,int> {
  ...
  };
  
  // partial specialization: both template parameters are pointer types
  template<typename T1, typename T2>
  class MyClass<T1*,T2*> {
  ...
  };
  
  template<typename T>
  class MyClass<T*,T*> {
  ...
  };
  ```

  

# Summary

- For class templates, only those member functions that are called are instantiated.
- You can specialize class templates for certain types.
- You can partially specialize class templates for certain types.
- Since C++17, class template arguments can automatically be deduced from constructors.
- Templates can only be declared and defined in global/namespace scope or inside class declarations.


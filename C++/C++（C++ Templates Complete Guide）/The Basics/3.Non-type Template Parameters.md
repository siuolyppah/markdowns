# Restrictions for Nontype Template Parameters

In general, they can be only constant ==<u>integral values</u>== (including enumerations), ==<u>pointers</u>== to objects/functions/members, <u>==lvalue references==</u> to objects or functions, or ==<u>std::nullptr_t</u>== (the type of nullptr).

~~Floating-point~~ numbers and ~~class-type objects~~ are not allowed as nontype template parameters

```cpp
template<double VAT> 		// ERROR: floating-point values are not
double process (double v)	 // allowed as template parameters
{
    return v * VAT;
}

template<std::string name> 	// ERROR: class-type objects are not
class MyClass { 			// allowed as template parameters
};
```



When passing template arguments to pointers or references, the objects must not be string literals, temporaries, or data members and other subobjects.

- In C++11, the objects also had to have external linkage.
- In C++14, the objects also had to have external or internal linkage.
- since C++17 if it has no linkage at all.

```cpp
template<char const* name>
class MyClass {
};
MyClass<"hello"> x; // ERROR: string literal "hello" not allowed

extern char const s03[] = "hi"; // external linkage
char const s11[] = "hi"; // internal linkage

int main()
{
    Message<s03> m03; // OK (all versions)
    Message<s11> m11; // OK since C++11
    static char const s17[] = "hi"; // no linkage
    Message<s17> m17; // OK since C++17
}
```



# Type auto for non-type template parameter

Since C++17, you can define a nontype template parameter to generically accept any type that is allowed for a nontype parameter. 


# key information

## define the template

- The type parameter represents an arbitrary type that ==is <u>*determined*</u> by the caller <u>when the caller *calls* the function</u>==.

- template parameters are divided by:
  - `type parameter`, ex:`<typename T>`
  - `non-type parameter`,  ex:`<int N>`



## Using template

- The process of replacing template parameters by concrete types is called ==instantiation==. It results in an instance of a template.

- void is a valid template argument provided the resulting code is valid.

  ```cpp
  template<typename T>
  T foo(T*)
  {}
  
  void* vp = nullptr;
  foo(vp);	// OK: deduces void foo(void*)
  ```

  

## ==Compiling and Linking About Template==

When a function template is used in a way that triggers its instantiation, a compiler will (at some point) need to see that template’s ==definition==.



## ==Type conversions During Type Deduction==（T如何推导）

在类型推断的时候自动的类型转换是受限制的：

- 如果***==形参==***是==引用类型==，==任何类型转换都不被允许==。通过模板类型参数T 定义的两个参数，它们实参的类型必须完全一样。
- 如果***==形参==***是==值类型==，那么只有退化（decay）这一类简单转换是被允许的：==const和volatile 限制符会被忽略==，==引用被转换成被引用的类型==，==raw array 和函数被转换为相应的指针类型==。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay）后必须一样。



```cpp
template<typename T>
T max (T a, T b);
...
int const c = 42;
max(i, c); // OK: T is deduced as int
max(c, c); // OK: T is deduced as int
int& ir = i;
max(i, ir); // OK: T is deduced as int
int arr[4];
foo(&i, arr); // OK: T is deduced as int*

max(4, 7.2); // ERROR: T can be deduced as int or double
std::string s;
foo("hello", s); // ERROR: T can be deduced as char const[6] or std::string
```



## Type Deduction ==for Default Argument==s

```cpp
template<typename T>
void f(T = ""){}

f(1); // OK: deduced T to be int, so that it calls f<int>(1)
f(); // ERROR: cannot deduce T
```

type deduction does not work for default call arguments.

To support this case, you also have to declare a default argument <u>for the *template parameter*</u>:

```cpp
template<typename T = std::string>
void f(T = ""){}

f(); // OK
```



## ==auto的推导规则==

> 注意区别模板的形参类型 T 在函数形参列表中的退化。

在初始化auto变量，以及返回值类型声明为auto时，如果目标（返回值或变量的修饰）是值类型，则发生退化。

```cpp
int i = 42;
const int& ir = i;

auto a = ir; // a will be int type
```

> 这里，a声明为值类型，发生decay，摘掉cv限定符，移去引用。



## 模板的重载相关问题

```cpp
// maximum of two int values:
int max (int a, int b)
{
    return b < a ? a : b;
}

// maximum of two values of any type:
template<typename T>
T max (T a, T b)
{
    return b < a ? a : b;
}

int main()
{
    ::max(7, 42); // calls the nontemplate for two ints
    ::max(7.0, 42.0); // calls max<double> (by argument deduction)
    ::max(’a’, ’b’); //calls max<char> (by argument deduction)
    ::max<>(7, 42); // calls max<int> (by argumentdeduction)
    ::max<double>(7, 42); // calls max<double> (no argumentdeduction)
    ::max(’a’, 42.7); //calls the nontemplate for two ints
}
```

>在模板参数推断时不允许自动类型转换，而常规函数是允许的.



# 最佳实践

- 简单类型（int等基础类型，字符串字面值，raw array，std::string_view)，用值传递。

  ==其他复杂类型，用引用传递==。

- 函数模板定义了一组适用于不同类型的函数。

- 当你重载函数模板的时候，所做的改变应当是特化类型或修改模板参数的个数。

- 确保在调用某个函数模板之前，编译器已经看到了相对应的模板定义


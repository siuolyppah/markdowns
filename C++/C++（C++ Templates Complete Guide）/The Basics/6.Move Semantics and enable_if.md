# Perfect Forwarding

Suppose you want to write generic code that forwards the basic property of passed arguments:

- Modifyable objects should be forwarded so that they still can be modified.
- Constant objects should be forwarded as read-only objects.
- Movable objects (objects we can “steal” from because they are about to expire) should be forwarded as movable objects.



如果没有完美转发模板：

```cpp
#include <utility>
#include <iostream>
class X {
    ...
};

void g (X&) {
    std::cout << "g() for variable\n";
}
void g (X const&) {
    std::cout << "g() for constant\n";
}
void g (X&&) {
    std::cout << "g() for movable object\n";
}

// let f() forward argument val to g():
void f (X& val) {
    g(val); // val is non-const lvalue => calls g(X&)
}
void f (X const& val) {
    g(val); // val is const lvalue => calls g(X const&)
}
void f (X&& val) {
    g(std::move(val)); // val is non-const lvalue => needs std::move() to call g(X&&)
}

int main()
{
    X v; // create variable
    X const c; // create constant
    f(v); // f() for nonconstant object calls f(X&) => calls g(X&)
    f(c); // f() for constant object calls f(X const&) => calls g(X const&)
    f(X()); // f() for temporary calls f(X&&) => calls g(X&&)
    f(std::move(v)); // f() for movable variable calls f(X&&) => calls g(X&&)
}
```

>Note that the code for movable objects (via an rvalue reference) differs from the other code: It needs a std::move() because ==according to language rules, move semantics is not passed through==.



使用完美转发：

```cpp
template<typename T>
void f (T&& val) {
    g(std::forward<T>(val)); // perfect forward val to g()
}
```

>==**<u>*Don’t assume that T&& for a template parameter T behaves as X&& for a specific type X. Different rules apply*</u>**==!:star:
>
>- X&& for <u>a specific type X</u> declares a parameter to be an rvalue reference. It can only be bound to a movable object (a prvalue, such as a temporary object, and an xvalue, such as an object passed with std::move(); see Appendix B for details). It is always mutable and you can always “steal” its value.
>- T&& for <u>a template parameter T</u> declares a forwarding reference (also called universal reference).It can be bound to a mutable, immutable (i.e., const), or movable object. Inside the function definition, the parameter may be mutable, immutable, or refer to a value you can “steal” the internals from.



# enable_if<>

```cpp
template<typename T>
typename std::enable_if<(sizeof(T) > 4)>::type foo() {
}
```

this definition of foo<>() is ignored if sizeof(T) > 4 yields false.



std::enable_if<> is a type trait that evaluates a given compile-time expression passed as its (first) template argument and behaves as follows:

- If the expression yields true, its type member type yields a type:
  - The type is void if no second template argument is passed.
  - Otherwise, the type is the second template argument type.
- If the expression yields false, the member type is not defined. Due to a template feature called SFINAE (substitution failure is not an error), which is introduced later , this has the effect that the function template with the enable_if expression is ignored.





the common way to use std::enable_if<> is to ==use an additional function template argument with a default value==:

```cpp
template<typename T,
typename = std::enable_if_t<(sizeof(T) > 4)>> 
void foo() {
}
```

which expands to

```cpp
template<typename T, typename = void> 
void foo() {
}
```

if sizeof(T) > 4.



you can define your own name for it using an alias template:

```cpp
template<typename T>
using EnableIfSizeGreater4 = std::enable_if_t<(sizeof(T) > 4)>;

template<typename T,
	typename = EnableIfSizeGreater4<T>>
void foo() {
}
```


# Avoid Objects with Names

Instead of:

```cpp
MyType x{42, "hello"};
foo(x); // x not used afterwards
```

it would be better to program:

```cpp
foo(MyType{42,"hello"});
```



> exactly:
>
> If compilers automatically detect that a value is used from an object that is at the end of its lifetime, they will ==automatically switch to move semantics==. This is the case when:
>
> - We pass a temporary object that will automatically be destroyed after the statement.
> - :star:==We return a local object by value==.





# Avoid Unnecessary std::move()

Returning a local object by value automatically uses move semantics if supported.

But, might try to force this with an explicit std::move():

```cpp
std::string foo()
{
    std::string s;
    return std::move(s); // BAD: don’t do this
}
```

Remember that std::move() is just a static_cast to an rvalue reference. Therefore, std::move(s) is an expression that yields the type std::string&&. this no longer matches the return type and therefore ==***disables the return value optimization***==. For types where move semantics is not implemented, this might even force the copying of the return value instead of just using the returned object as the return value.



:star:==Therefore, if you return local objects by value, do not use std::move()==.

```cpp
std::string foo()
{
    std::string s;
   	return s; // best performance (return value optimization or move)
}
```



:star:Using std::move() when you already have a temporary object is at least ==redundant==.

```cpp
std::string s{createString()}; // OK
std::string s{std::move(createString())}; // BAD: redundant, don’t do this
```



# 关于函数形参采用值还是引用类型:star:

==Taking a parameter by value== and moving it to where the new value is needed is only useful ==when we store the passed value somewhere== as a new value (so that we need new memory for it anyway). When modifying an existing value, this policy might be counterproductive.

>即：
>
>- 如果被传递的参数，将在某个地方被存储下来：最好用值类型，之后移动它。
>- 如果是对一些已拥有内存的变量的修改：两者都可。

```cpp
class Person {
private:
    std::string name;
    std::vector<std::string> values;

public:
    Person(std::string n, std::vector<std::string> v)
        : first{std::move(n)}, values{std::move(v)} 
    {}

    void setFirstname(const std::string& s) { // take by lvalue reference
        first = s; // and assign
    }

    // better pass by value and move to create a new element:
    void addValue(std::string s) { // take by value
        values.push_back(std::move(s)); // and move into the collection
    }
};
```



# 关于继承体系解决slice的问题:star:

>[c++ - What is object slicing? - Stack Overflow](https://stackoverflow.com/questions/274626/what-is-object-slicing)



slice的问题：

```cpp
B b1;
B b2;

A& a_ref = b2;
a_ref = b1;
//b2 now contains a mixture of b1 and b2!
```



解决方案：

```cpp
class A {
    public:
    virtual A& operator= (const A& a) {
        assign(a);
        return *this;
    }

    protected:
    void assign(const A& a) {
        // copy members of A from a to this
    }
};

class B : public A {
    public:
    virtual B& operator= (const A& a) {
        if (const B* b = dynamic_cast<const B*>(&a))
            assign(*b);
        else
            throw bad_assignment();
        return *this;
    }

    protected:
    void assign(const B& b) {
        A::assign(b); // Let A's assign() copy members of A from b to this
        // copy members of B from b to this
    }
};
```



# Summary

- Avoid objects with names.
- Avoid unnecessary std::move(). Especially do not use it when returning a local object.
- Constructors that initialize members from parameters, for which move operations are cheap, should take the argument by value and move it to the member.
- Constructors that initialize members from parameters, for which move operations take a significant amount of time, should be overloaded for move semantics for best performance.
- In general, creating and initializing new values from parameters, for which move operations are cheap, should take the arguments by value and move. However, do not take by value and move to update/modify existing values.


# 没有移动语义的C++03代码

```cpp
#include <string>
#include <vector>
std::vector<std::string> createAndInsert()
{
    std::vector<std::string> coll; // create vector of strings
    coll.reserve(3); // reserve memory for 3 elements
    std::string s = "data"; // create string object
    coll.push_back(s); // insert string object
    coll.push_back(s+s); // insert temporary string
    coll.push_back(s); // insert string
    return coll; // return vector of strings
}

int main()
{
    std::vector<std::string> v; // create empty vector of strings
	v = createAndInsert(); // assign returned vector of strings
}
```

1. 执行完`std::string s = "data";`后：

   ![image-20221030235353836](1.The%20Power%20of%20Move%20Semantics.assets/image-20221030235353836.png)

2. 执行完`coll.push_back(s);`后：

   ![image-20221030235452421](1.The%20Power%20of%20Move%20Semantics.assets/image-20221030235452421.png)

   > C++03只有值语义，因此执行了一次*深拷贝*。

3. `coll.push_back(s+s);`

   1. create the temporary string s+s:

      ![image-20221030235649972](1.The%20Power%20of%20Move%20Semantics.assets/image-20221030235649972.png)

   2. insert this temporary string into the vector coll. As always, the container creates a copy of the passed value.

      ![image-20221030235727330](1.The%20Power%20of%20Move%20Semantics.assets/image-20221030235727330.png)

   3. ==At the end of the statement==, ==the <u>***temporary***</u> string s+s is ***destroyed***== because we no longer need it.

      ![image-20221030235809391](1.The%20Power%20of%20Move%20Semantics.assets/image-20221030235809391-1667145489880-3.png)

   >可优化点：we create a copy of a temporary string and destroy the source of the copy immediately afterwards, which means that we unnecessarily allocate and free memory that we could have just moved from the source to the copy.

4. `coll.push_back(s);`

   ![image-20221031000015561](1.The%20Power%20of%20Move%20Semantics.assets/image-20221031000015561.png)

   > 可优化点：the value of s is no longer needed some optimization could
   > use the memory of s as memory for the new element in the vector instead.

5. `return coll;`

   - 可能发生==named return value optimization(NRVO)优化==。

     This means that the compiler can generate code so that <u>coll is just used as the return value</u>.

     In that case, at the end of the return statement, coll now becomes the return value and the destructor of s is called, which frees the memory
     allocated when it was declared.

     ![image-20221031000733104](1.The%20Power%20of%20Move%20Semantics.assets/image-20221031000733104.png)

   - 如果不发生NRVO优化的话，将拷贝构造一个新的临时对象，并析构s和coll。

6. `v = createAndInsert();`

   1. the assignment operator will create a deep copy of the whole return value.

      ![image-20221031001038866](1.The%20Power%20of%20Move%20Semantics.assets/image-20221031001038866.png)

   2. right after that, we no longer need the temporary return value and we destroy it.

      ![image-20221031001050932](1.The%20Power%20of%20Move%20Semantics.assets/image-20221031001050932.png)

   >优化点：Again, we create a copy of a temporary object and destroy the source of the copy immediately afterwards,



==The <u>*unnecessary memory allocations*</u> were caused by:==

- <u>Inserting a temporary</u> object into the collection.

  > collection复制了temporary object，但却表达式结束时立即对其进行了析构。

- Inserting an object into the collection where we no longer need the value.

  > 即便是接下来没用（等着被析构）的对象，仍然被拷贝了一次。

- <u>Assigning a temporary</u> vector with all its elements.

  > 用临时量进行赋值时，对临时量进行了拷贝，却在表达式结束后立即对其进行了析构。



# 使用移动语义的C++11代码

```cpp
#include <string>
#include <vector>
std::vector<std::string> createAndInsert()
{
    std::vector<std::string> coll; // create vector of strings
    coll.reserve(3); // reserve memory for 3 elements
    std::string s = "data"; // create string object
    coll.push_back(s); // insert string object
    coll.push_back(s+s); // insert temporary string
    coll.push_back(std::move(s)); // insert string (we no longer need the value of s)
    return coll; // return vector of strings
}

int main()
{
    std::vector<std::string> v; // create empty vector of strings
    v = createAndInsert(); // assign returned vector of strings
}
```

1. 执行完`coll.push_back(s);`

   ![image-20221031002133188](1.The%20Power%20of%20Move%20Semantics.assets/image-20221031002133188.png)

2. `coll.push_back(s+s);`

   1. create the temporary string s+s:

      ![image-20221031002249621](1.The%20Power%20of%20Move%20Semantics.assets/image-20221031002249621.png)

   2. here something different happens now:
      we ==steal the memory for the value from s+s and move it to the new element of coll==.

      ![image-20221031002324657](1.The%20Power%20of%20Move%20Semantics.assets/image-20221031002324657.png)

      >The compiler can signal this fact because it knows that right after performing the push_back() call, the temporary object s+s will be destroyed. So, we <u>call a different implementation</u> of push_back() provided for the case when the caller no longer needs that value.
      >
      >Essentially, s+s is modified so that it gets the state of <u>an empty string</u>.

   3. At the end of the statement, the temporary string s+s is destroyed because we no longer need it.
      However, because the temporary string is no longer the owner of the initial memory, the destructor will <u>not free this memory</u>.

      > Actually, the point of the temporary object s+s was assigned a nullptr.

3. `coll.push_back(std::move(s));`

   in this call, we have marked s with std::move(), which semantically means “<u>I ==*no longer need this value*== here.</u>”. As a consequence, we have another call of
   the other implementation of push_back(). Then the third element steals the value by moving the ownership of the memory for the value from s to its
   copy.

   ![image-20221031003101169](1.The%20Power%20of%20Move%20Semantics.assets/image-20221031003101169.png)

4. `return coll;`

   - 若发生NRVO优化，object coll 将成为返回值，s将析构（但因为它内部此时为空指针，析构并不会进行对内存的free）。

     ![image-20221031003809245](1.The%20Power%20of%20Move%20Semantics.assets/image-20221031003809245.png)

   - 若未发生优化，将发生Move Construct，返回值对象将***偷取*** object coll 中的数据，s和coll将析构。

5. `v = createAndInsert();`

   由于将要 copy (assign) a value from a temporary return value that is about to die，移动语义允许我们调用移动赋值函数，将数据从source object中偷取过来。相对的，retval 内部则指向了nullptr。

   ![image-20221031004038115](1.The%20Power%20of%20Move%20Semantics.assets/image-20221031004038115.png)

   在语句的末尾，返回值对象retval被析构（但此时并不会有对堆内存进行释放的操作）。



# Const Return Values

The fact that const disables move semantics also has consequences for declaring return types. A const return value cannot be moved.



When returning by value, do not declare the return value as a whole to be const. Use const only to declare parts of your return type (such as the object a returned reference or pointer refers to):

```cpp
const std::string getValue(); // BAD: disables move semantics for return values
const std::string& getRef(); // OK
const std::string* getPtr(); // OK
```



# Summary

- Move semantics allows us to optimize the copying of objects, where we no longer need the value. It ==can be used <u>*implicitly (for unnamed temporary objects or local return values)*</u>== or ==<u>*explicitly (with std::move())*</u>==.

- std::move() means I no longer need this value here. It marks the object as movable. An object marked with std::move() is not (partially) destroyed (the destructor still will be called).

- By declaring a function with a non-const rvalue reference (such as std::string&&), you define an
  interface where the caller semantically claims that it no longer needs the passed value. The implementer
  of the function can use this information to optimize its task by “stealing” the value or do any other modification with the passed argument. Usually, the implementer also has to ensure that the passed argument is in a valid state after the call.

- ==Copy semantics is used as a fallback for move semantics== (if copy semantics is supported). If there is no implementation taking an rvalue reference, any implementation taking an ordinary const lvalue reference(such as ==const std::string&==) is used. This fallback is then used even if the object is explicitly marked with std::move().

- Calling std::move() for a const object usually has no effect.

  > const意味着不能对object进行修改，从而无法进行优化。与右值语义存在冲突。

- If you return by value (not by reference), ==do not declare the return value as a whole to be const==.(except return by returning reference or pointer).

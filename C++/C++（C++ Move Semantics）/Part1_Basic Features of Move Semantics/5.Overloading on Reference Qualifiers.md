# Return Type of Getters:star:

```cpp
class Person
{
private:
    std::string name;

public:
    std::string getName() && { // when we no longer need the value
        return std::move(name); // we steal and return by value
    }
    
    const std::string& getName() const& { // in all other cases
        return name; // we give access to the member
    }
};
```

>in this case we return <u>no local object</u>; we return a member, for which <u>the lifetime does not end with the end of the member function</u>.



We overload the getter with different reference qualififiers in the same way as when overloading a function for && and const& parameters:

- The version with the && qualififier is used when we have an object where we no longer need the value (an object that is about to die or that we have marked with std::move()).
- The version with the const& qualififier is used in all other cases. It always fifits but is only the fallback if we cannot take the && version. Thus, this function is used if we have an object that is not about to die or marked with std::move().



Now we have both good performance and safety:

```cpp
Person p{"Ben"};
std::cout << p.getName(); // 1) fast (returns reference)
std::cout << returnPersonByValue().getName(); // 2) fast (uses move())
```



# **Overloading on Qualififiers**:star:

we can overload member functions on Qualififiers:

```cpp
#include <iostream>
class C {
public:
    void foo() const& {
        std::cout << "foo() const&\n";
    }
    void foo() && {
        std::cout << "foo() &&\n";
    }
    void foo() & {
        std::cout << "foo() &\n";
    }
    void foo() const&& {
        std::cout << "foo() const&&\n";
    }
};

int main()
{
    C x;
    x.foo(); // calls foo() &
    C{}.foo(); // calls foo() &&
    std::move(x).foo(); // calls foo() &&
   
    const C cx;
    cx.foo(); // calls foo() const&
    std::move(cx).foo(); // calls foo() const&&
}
```



Overloading for both reference and non-reference qualififiers it is not allowed:

```cpp
class C {
    public:
    void foo() &&;
    void foo() const; // ERROR: canâ€™t overload by both reference and value qualifiers
};
```


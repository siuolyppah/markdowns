# Rvalue Reference

The name ==rvalue reference== comes from the fact that these objects can usually refer only to ==rvalues==, a ==***value category***== for ==temporary objects that do not have a name== and ==objects marked with std::move()==.

>:star:右值引用，只能引用右值（不具名对象和std::move标记的对象）。

```cpp
std::string returnStringByValue(); // forward declaration

std::string s{"hello"};

std::string&& r1{s}; // ERROR
std::string&& r2{std::move(s)}; // OK
std::string&& r3{returnStringByValue()}; // OK, extends lifetime of return value
```



:star:If compilers automatically detect that ==a value is used from an object that is at the end of its lifetime==, they ==will automatically switch to move semantics==. This is the case when:

- We pass the value of a temporary object that will automatically be destroyed after the statement.
- We pass a non-const object marked with std::move().



# std::move()

If you have an object for which the lifetime does not end when you use it, you can mark it with std::move() <u>to express</u> “I no longer need this value here.” std::move() does not move; it only sets a temporary marker in the context where the expression is used.



- Header file: `#include <utility> `

- Implementation of std::move():

  :star:==std::move() is nothing but a static_cast to an rvalue reference==. You can achieve the same effect by calling static_cast manually as follows:

  ```cpp
  foo(static_cast<decltype(obj)&&>(obj)); // same effect as foo(std::move(obj))
  ```

  >:star:Note that ==the static_cast does a bit more than only changing the type of the object here==. It ==also enables the object to be passed to an rvalue reference== (remember that passing objects with names to rvalue references  is usually not allowed).



# Overloading by Different References

After introducing rvalue references, we now have ==three major ways of call-by-reference==:

1. `void foo(const std::string& arg)`

   can pass:

   - A modifiable named object
   - A const named object
   - A temporary object that does not have a name
   - An object marked with std::move()

2. `void foo(std::string& arg)`

   :star:can only pass:

   - A modifiable named object

3. `void foo(std::string&& arg)`

   can only pass:

   - A temporary object that does not have a name
   - An non-const object marked with std::move()



# Passing by value could Use move  semantic

```cpp
void fooByVal(std::string str); // takes the object by value
void fooByRRef(std::string&& str); // takes the object by rvalue reference

std::string s1{"hello"}, s2{"hello"};

fooByVal(std::move(s1)); // s1 is moved
fooByRRef(std::move(s2)); // s2 might be moved
```

- :star:调用fooByVal()时，形参str是通过移动构造==产生==的。
- 调用fooByRRer时，形参str对s2进行了==引用==，是否发生移动语义依赖于函数的实现。





# Summary:star:

- Rvalue references are declared with && and no const.
- They can be initialized by temporary objects that do not have a name or non-const objects marked with std::move().
- Rvalue references extend the lifetime of objects returned by value.
- std::move() is a static_cast to the corresponding rvalue reference type. This allows us to pass a named object to an rvalue reference.
- Objects marked with std::move() can also be passed to functions taking the argument by value. In that case, move semantics is used to initialize the parameter, which can make call-by-value pretty cheap.
- const rvalue references are possible but implementing against them usually makes no sense.
- Moved-from objects should be in a valid but unspecified state. The C++ standard library guarantees that for its types. You can still (re)use them providing you do not make any assumptions about their value.
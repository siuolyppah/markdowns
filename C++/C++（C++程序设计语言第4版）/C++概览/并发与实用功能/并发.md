# ä»»åŠ¡å’Œthread

- ä»»åŠ¡ï¼šé‚£äº›å¯ä»¥ä¸å…¶ä»–è®¡ç®—ï¼Œå¹¶è¡Œæ‰§è¡Œçš„è®¡ç®—

  > ## ğŸ’¡ ä»¥å‡½æ•°ï¼Œæˆ–å‡½æ•°å¯¹è±¡çš„å½¢å¼å‡ºç°ã€‚

- çº¿ç¨‹ï¼šæ˜¯ä»»åŠ¡åœ¨ç¨‹åºä¸­çš„ç³»ç»Ÿçº§è¡¨ç¤º



```C++
void f();					// å‡½æ•°

struct F{					// å‡½æ•°å¯¹è±¡
    void operator(){}		// Få—²ç”¨è¿ç®—ç¬¦
}

void user(){
    thread t1{f};			// f()åœ¨å•ç‹¬çš„çº¿ç¨‹ä¸­è¿›è¡Œ
    thread t2{F()};			// F()()åœ¨å•ç‹¬çš„çº¿ç¨‹ä¸­æ‰§è¡Œ
    
    t1.join();
    t2.join();
}
```



# ä¼ é€’å‚æ•°

ä»»åŠ¡é€šå¸¸éœ€è¦å¤„ç†æ•°æ®ï¼Œå¯ä»¥å°†æ•°æ®ï¼ˆæˆ–æŒ‡å‘æ•°æ®çš„æŒ‡é’ˆæˆ–å¼•ç”¨ï¼‰ï¼Œä½œä¸ºå‚æ•°ä¼ é€’ç»™ä»»åŠ¡ã€‚



ä¾‹å¦‚ï¼š

```C++
void f(vector<double>& v);

struct F {
	vector<double>& v;
	F(vector<double>& vv) :v(vv) {}
	void operator()();
};

int main() {
	
	vector<double> some_vec{ 1,2,3,4,5,6,7,8,9 };
	vector<double> vec2{ 10,11,12,13,14,15 };

	thread t1{ f,some_vec };
	thread t2{ F(vec2) };

	t1.join();
	t2.join();
}
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`F{vec2}`å°†æŒ‡å‘ä¸€ä¸ªå‚æ•°(vector)çš„å¼•ç”¨ä¿å­˜åœ¨Fä¸­ã€‚

> å°†vec2ä»¥ä¼ å€¼æ–¹æ³•è¿›è¡Œä¼ é€’ï¼Œå¯ä»¥é¿å…åœ¨æ‰§è¡Œæ—¶å—åˆ°å…¶ä»–ä»»åŠ¡è®¿é—®vec2çš„å½±å“ã€‚



ä¸Šé¢çš„ä»£ç `{f,some_vec}`åˆå§‹åŒ–ä¸€ä¸ªçº¿ç¨‹å¯¹è±¡ï¼Œå®ƒ**ä½¿ç”¨threadçš„å¯å˜å‚æ•°æ¨¡æ¿æ„é€ å‡½æ•°ï¼Œæ¥æ”¶ä¸€ä¸ªä»»æ„çš„å‚æ•°åºåˆ—**ã€‚ç¼–è¯‘å™¨æ£€æŸ¥ç¬¬ä¸€ä¸ªå¯¹è±¡ï¼ˆå‡½æ•°æˆ–å‡½æ•°å¯¹è±¡ï¼‰ï¼Œæ˜¯å¦èƒ½è¢«åç»­çš„å‚æ•°æ¥è°ƒç”¨ã€‚



# è¿”å›ç»“æœ

- é€šè¿‡å‚æ•°ï¼Œå¯ä»¥è¿”å›ç»“æœã€‚ä½†ä¸å¤ªä¼˜é›…ã€‚



# å…±äº«æ•°æ®

## mutexä¸é”

åœ¨è®¿é—®å…±äº«æ•°æ®æ—¶ï¼Œéœ€è¦è¿›è¡ŒåŒæ­¥æ“ä½œï¼Œä»¥ç¡®ä¿åŒä¸€æ—¶åˆ»è‡³å¤šä¸€ä¸ªä»»åŠ¡è®¿é—®æ•°æ®ã€‚



ä½¿ç”¨â€œäº’æ–¥å¯¹è±¡â€mutexã€‚threadä½¿ç”¨`lock()`æ“ä½œæ¥è·å–ä¸€ä¸ªäº’æ–¥å¯¹è±¡ï¼š

```C++
mutex m;	// æ§åˆ¶å…±äº«æ•°æ®è®¿é—®
int sh;		// å…±äº«çš„æ•°æ®

void f() {
	unique_lock<mutex> lck{ m };	// è·å–mutex
	sh += 7;						// å¤„ç†å…±äº«æ•°æ®
}	// éšå¼é‡Šæ”¾mutex
```

unique_lockçš„æ„é€ å‡½æ•°ï¼Œè·å–äº†äº’æ–¥å¯¹è±¡ï¼ˆé€šè¿‡è°ƒç”¨m.lock()ï¼‰ã€‚

å¦‚æœå¦ä¸€ä¸ªçº¿ç¨‹å·²ç»è·å¾—äº†äº’æ–¥å¯¹è±¡ï¼Œåˆ™å½“å‰çº¿ç¨‹ä¼šé˜»å¡ç­‰å¾…ã€‚

ä¸€æ—¦çº¿ç¨‹å®Œæˆäº†å¯¹å…±äº«æ•°æ®çš„è®¿é—®ï¼Œunique_lockä¼šé‡Šæ”¾mutexï¼ˆé€šè¿‡è°ƒç”¨m.unlock()ï¼‰ã€‚



é€šå¸¸å°†å…±äº«æ•°æ®å’Œmutexå¯¹è±¡è¿›è¡Œå°è£…ï¼š

```C++
class Record{
public:
    mutex m;
    // ...
}
```



å¦‚æœéœ€è¦åŒæ—¶è®¿é—®å¤šä¸ªèµ„æºæ¥æ‰§è¡ŒæŸä¸ªæ“ä½œï¼Œå¯èƒ½å¯¼è‡´æ­»é”ã€‚

å¦‚thread1è·å–äº†mutex1ï¼Œè¯•å›¾è·å–mutex2ï¼›

å¦‚thread2è·å–äº†mutex2ï¼Œè¯•å›¾è·å–mutex1.



æ ‡å‡†åº“æä¾›äº†ä¸€ä¸ªå¯ä»¥**åŒæ—¶è·å–å¤šä¸ªé”**çš„æ“ä½œï¼š

```C++
void f() {
	// ...

	// æ¨è¿ŸåŠ é”ï¼Œæ­¤æ—¶è¿˜æœªå°è¯•è·å–mutex
	unique_lock<mutex> lck1{ m1,defer_lock };	
	unique_lock<mutex> lck2{ m2,defer_lock };
	unique_lock<mutex> lck3{ m3,defer_lock };

	lock(lck1, lck2, lck3);	// è·å–å…¨éƒ¨ä¸‰ä¸ªé”
	// å¤„ç†å…±äº«æ•°æ®
}// éšå¼é‡Šæ”¾æ‰€æœ‰mutex
```

`lock()`è°ƒç”¨ï¼Œä»…ä¼šåœ¨è·å–äº†å…¨éƒ¨çš„mutexå®å‚åæ‰ä¼šç»§ç»­æ‰§è¡Œã€‚

unique_lockçš„ææ„å‡½æ•°ï¼Œä¿è¯äº†å½“threadç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œmutexä¼šé‡Šæ”¾ã€‚



## æ¡ä»¶å˜é‡ä¸çº¿ç¨‹é—´é€šä¿¡

é€šè¿‡å¤–éƒ¨äº‹ä»¶ï¼Œå®ç°çº¿ç¨‹é—´é€šä¿¡çš„åŸºæœ¬æ–¹æ³•æ˜¯ä½¿ç”¨condition_variableï¼Œå®ƒå®šä¹‰åœ¨<condition_variable>ä¸­ã€‚

æ¡ä»¶å˜é‡ï¼Œæä¾›äº†ä¸€ç§æœºåˆ¶ï¼šå…è®¸ä¸€ä¸ªthreaç­‰å¾…å¦å¤–ä¸€ä¸ªthreadã€‚ç‰¹åˆ«æ˜¯ï¼Œ**å®ƒå…è®¸ä¸€ä¸ªthreadç­‰å¾…æŸä¸ªæ¡ä»¶ï¼ˆconditionï¼Œé€šå¸¸ç§°ä¸ºä¸€ä¸ªäº‹ä»¶ï¼Œeventï¼‰å‘ç”Ÿ**ï¼Œè¿™ç§æ¡ä»¶é€šå¸¸æ˜¯å…¶ä»–threadå®Œæˆå·¥ä½œäº§ç”Ÿçš„ç»“æœã€‚



```C++
class Message {		// é€šä¿¡çš„å¯¹è±¡
	// ...
};

queue<Message> mqueue;		// æ¶ˆæ¯çš„é˜Ÿåˆ—
condition_variable mcond;	// é€šä¿¡ç”¨çš„æ¡ä»¶å˜é‡
mutex mmutex;				// é”æœºåˆ¶

void consumer() {
	while (true)
	{
		unique_lock<mutex> lck{ mmutex };	// è·å–mmutex

		while (mqueue.empty()) {
			mcond.wait(lck);				//// é‡Šæ”¾lckå¹¶ç­‰å¾…
		}			
											// è¢«å”¤é†’åé‡æ–°è·å–lck
		
		auto m = mqueue.front();			// è·å–æ¶ˆæ¯
		mqueue.pop();
		lck.unlock();

		// å¤„ç†m
	}
}
```

é€šè¿‡mutexï¼Œå¯¹queueå’Œcondition_variableè¿›è¡Œä¿æŠ¤ã€‚

**å½“çº¿ç¨‹åœ¨æ¡ä»¶å˜é‡ä¸Šç­‰å¾…æ—¶ï¼Œä¼šé‡Šæ”¾å·²æŒæœ‰çš„é”ï¼Œç›´è‡³è¢«å”¤é†’åé‡æ–°è·å–é”**ã€‚



```C++
void producer() {
	while (true)
	{
		Message m;

		unique_lock<mutex> lck{ mmutex };	// ä¿æŠ¤é˜Ÿåˆ—ä¸Šçš„æ“ä½œ
		mqueue.push(m);
		mcond.notify_one();					// é€šçŸ¥
	}// é‡Šæ”¾é”ï¼ˆåœ¨ä½œç”¨åŸŸç»“æŸæ—¶ï¼‰
}
```





# ä»»åŠ¡é€šä¿¡

æ ‡å‡†åº“æä¾›äº†ä¸€äº›ç‰¹æ€§ï¼Œå…è®¸ç¨‹åºå‘˜åœ¨æŠ½è±¡çš„ä»»åŠ¡å±‚ï¼ˆå·¥ä½œå¹¶å‘æ‰§è¡Œï¼‰è¿›è¡Œæ“ä½œï¼Œè€Œä¸æ˜¯åœ¨åº•å±‚çš„çº¿ç¨‹å’Œé”çš„å±‚æ¬¡ç›´æ¥è¿›è¡Œæ“ä½œï¼š

- futureå’Œpromisï¼Œç”¨æ¥ä»ä¸€ä¸ªç‹¬ç«‹çº¿ç¨‹ä¸Šåˆ›å»ºå‡ºçš„ä»»åŠ¡è¿”å›ç»“æœã€‚
- packaged_taskï¼Œæ˜¯å¸®åŠ©å¯åŠ¨ä»»åŠ¡ä»¥åŠè¿æ¥è¿”å›ç»“æœçš„æœºåˆ¶ã€‚
- async()ä»¥éå¸¸ç±»ä¼¼å‡½æ•°çš„æ–¹å¼ï¼Œå¯åŠ¨ä¸€ä¸ªä»»åŠ¡ã€‚

è¿™äº›ç‰¹æ€§éƒ½å®šä¹‰åœ¨`<future>`ä¸­ã€‚



## futureå’Œpromise

futureå’Œpromiseçš„å…³é”®ç‚¹ï¼Œåœ¨äºå®ƒä»¬**å…è®¸åœ¨ä¸¤ä¸ªä»»åŠ¡é—´ä¼ è¾“å€¼ï¼Œè€Œæ— éœ€æ˜¾å¼çš„ä½¿ç”¨é”**ã€‚



åŸºæœ¬æ€è·¯å¾ˆç®€å•ï¼šå½“ä¸€ä¸ªä»»åŠ¡ï¼Œéœ€è¦å‘å¦ä¸€ä¸ªä»»åŠ¡ä¼ è¾“æŸä¸ªå€¼æ—¶ï¼Œå®ƒæŠŠæ”¾å…¥promiseä¸­ã€‚

![image-20220719214517839](%E5%B9%B6%E5%8F%91.assets/image-20220719214517839.png)



```C++
void f(promise<int>& px) {	// ä¸€ä¸ªä»»åŠ¡ï¼šå°†ç»“æœæ”¾å…¥px
	try {
		px.set_value(100);
	}
	catch (...) {
        // å°†å¼‚å¸¸ä¼ é€’ç»™futureçš„çº¿ç¨‹
		px.set_exception(current_exception());
	}
}


int main() {
	promise<int> px;
	future<int> fx = px.get_future();	
	
	try {
		int x = fx.get();	// å¦‚å¿…è¦ï¼Œç­‰å¾…å€¼å‡†å¤‡å¥½
	}
	catch (...) {			// é”™è¯¯ï¼šxä¸èƒ½æ­£ç¡®è®¡ç®—
		// å¤„ç†é”™è¯¯
	}
}
```

å¯¹äº`future<X>.get()`ï¼š

- å¦‚æœå€¼è¿˜æœªå‡†å¤‡å¥½ï¼Œåˆ™çº¿ç¨‹å°†é˜»å¡ç­‰å¾…
- å¦‚æœå€¼æ— æ³•æ­£ç¡®åœ°è®¡ç®—å‡ºæ¥ï¼Œåˆ™get()ä¼šæŠ›å‡ºä¸€ä¸ªå¼‚å¸¸



## packaged_task

```C++
double accum(double* beg, double* end, double init) {
	return accumulate(beg, end, init);
}

int main() {
	using Task_type = double(double*, double*, double);	 // ä»»åŠ¡çš„ç±»å‹

	packaged_task<Task_type> pt0{ accum };				// æ‰“åŒ…ä»»åŠ¡
	packaged_task<Task_type> pt1{ accum };

	future<double> f0{ pt0.get_future() };				// è·å–future
	future<double> f1{ pt1.get_future() };	

	vector<double> v;
	double* first = &v[0];
	thread t1{ move(pt0),first, first + v.size() / 2,0 };
	thread t2{ move(pt1),first + v.size() / 2, first + v.size(),0 };

	double result = f0.get() + f1.get();
}
```



## async()

```C++
double comp(vector<double>& v) {
	if (v.size() < 10000)
		return accum(v.begin(), v.end(), 0.0);

	auto v0 = &v[0];
	auto sz = v.size();

	future<double> f0 = async(accum, v0, v0 + sz / 2, 0.0);
	future<double> f1 = async(accum, v0 + sz / 2, v0 + sz, 0.0);

	return f0.get() + f1.get();
}
```

å¯¹äºéœ€è¦ä½¿ç”¨å…±äº«èµ„æºï¼Œéœ€è¦é”æœºåˆ¶çš„ä»»åŠ¡ï¼Œä¸è¦ä½¿ç”¨async()ã€‚


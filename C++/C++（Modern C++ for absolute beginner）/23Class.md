# Class Members

- A Class is composed by ==*Members*==.
  1. Data Member;
  2. Function Member;
  3. Type Member.



# ==Access Specifier==

- ==Visibility/Access Specifier==:

  1. public;

  2. protected;

     ==protected 成员和 private 成员类似，也不能通过对象访问==。

     ==但是当存在继承关系时，基类中的 protected 成员可以在派生类中使用，而基类中的 private 成员不能在派生类中使用==。

     ```cpp
     class MyBaseClass
     {
         protected:
         char c;
         int x;
     };
     
     class MyDerivedClass : public MyBaseClass
     {
         // c and x also accessible here
     };
     
     int main()
     {
         MyDerivedClass o;
         o.c = 'a'; // Error, not accessible to object
         o.x = 123; // error, not accessible to object
     }
     ```
  
  3. private:
  
     Private access members, ==are accessible only to other class members(in this class), not objects==.
  
  >- Default access specifier for class is private.
  >
  >- Default access specifier for struct is public.



# Constructor

1. Default Constructor:

   A constructor without parameters or with default parameters set is called a default constructor.

   ```cpp
   Class MyClass{
       MyClass();
       // or 
       MyClass(int x=10);
   }
   ```

   >If a default constructor is not explicitly defined in the code, the compiler will
   ><u>generate</u> a default constructor. 
   >
   >But when we define a constructor of our own, the one that needs parameters, the default constructor gets <u>removed</u> and is not generated by a compiler.

2. Copy Constructor:

   When we initialize an object with another object of the same class, we invoke a copy constructor.

   ```cpp
   MyClass(const MyClass& rhs)
   ```

   >If we do not supply our copy constructor, the compiler generates a default
   >copy constructor that performs the so-called <u>*shallow copy*</u>.

3. Copy <u>Assignment</u>:

   when we initialize an object with another object using the = operator on the same line, then the copy operation uses the copy constructor.

   ```cpp
   MyClass copyfrom;
   
   MyClass copyto = copyfrom; // on the same line, uses a copy constructor
   
   copyto = copyfrom; // uses a copy assignment operator
   ```

   ```cpp
   MyClass& operator=(const MyClass& rhs)
   ```

4. Move Constructor

   ```cpp
   MyClass (MyClass&& rhs)
   ```

5. Move Assignment

   ```cpp
   MyClass& operator=(MyClass&& otherobject)
   ```

   



# member initializer list

```cpp
class MyClass
{
    public:
    int x, y;
    MyClass(int xx, int yy)
        : x{ xx }, y{ yy } // member initializer list
    {}
};
```



# ==Move Semantics==

Every expression can find itself on the left-hand side or the right-hand side of the
assignment operator. The expressions that can be used on the left-hand side are called ==lvalues==, such as variables, function calls, class members, etc. The expressions that can be used on the right-hand side of an assignment operator are called ==rvalues==, such as literals, and other expressions.



- To cast something to an rvalue reference, we use the ==std::move== function.



# Operator Overload

We can overload the following operators:

```cpp
+ - * / % ^ & | ~ ! = < > == != <= >= += -= *= /= %= ^= &= |= << >> >>= <<= && || ++ -- , ->* -> () []
```



```cpp
class MyClass{
	MyClass& operator+=(const MyClass& rhs)
	friend MyClass operator+(MyClass lhs, const MyClass& rhs)
}
```





# Inheritance

- public inherit:
  - 基类中所有 public 成员在派生类中为 public 属性；
  - 基类中所有 protected 成员在派生类中为 protected 属性；
  - 基类中所有 private 成员在派生类中不能使用。
- protected inherit:
  - 基类中的所有 public 成员在派生类中为 protected 属性；
  - 基类中的所有 protected 成员在派生类中为 protected 属性；
  - 基类中的所有 private 成员在派生类中不能使用。
- private inherit:
  - 基类中的所有 public 成员在派生类中均为 private 属性；
  - 基类中的所有 protected 成员在派生类中均为 private 属性；
  - 基类中的所有 private 成员在派生类中不能使用。

> - ==**总的来说，public成员和protected成员都会被继承，并且访问修饰符会改变**==。
>
> - ==**private 和 protected都只能通过类访问，不能通过对象访问。区别是子类可以继承父类的protected成员**==。





# Polymorphism and Virtual function

```cpp
#include <iostream>
class MyBaseClass
{
public:
    virtual void dowork()
    {
        std::cout << "Hello from a base class." << '\n';
    }
};

class MyDerivedClass : public MyBaseClass
{
public:
    void dowork()
    {
        std::cout << "Hello from a derived class." << '\n';
    }
};

int main()
{
    MyBaseClass* o = new MyDerivedClass;
    o->dowork();
    delete o;
}
```



- A ==virtual function== is a function whose behavior can be overridden in subsequent derived classes.

- ==Pure virtual functions== do not have definitions and are also called interfaces.

  Pure virtual functions must be re-defined in the derived class.

  Classes having at least one pure virtual function are called abstract classes and cannot be instantiated.

- One important thing to add is that <u>a base class must have a virtual destructor</u> <u>if it is to be used in a polymorphic scenario</u>.
# 模式匹配

- 对元组的模式匹配：

  ```haxe
  first :: (a, b, c) -> a  
  first (x, _, _) = x 
  ```

  > 由于元组元素的数量与类型，决定了元组的类型。所以不能匹配任意数量的元组。

- 对List的模式匹配：

  - 分隔头尾：

    ```haskell
    head' :: [a] -> a  
    head' [] = error "Can't call head on an empty list, dummy!"
    head' (x:_) = x  
    ```

  - 分别绑定单个元素：

    ```haxe
    exchange :: [a] -> [a]
    exchange (x:y:[]) = [y, x]
    ```

    或者：
    ```haskell
    exchange :: [a] -> [a]
    exchange [x, y] = [y, x]
    ```

  - 用`_`绑定不固定长度的List：

    ```haskell
    len :: Num p => [a] -> p
    len [] = 0
    len (_ : xs) = 1 + len xs
    ```

  > ==核心：`[x,y]`，就是`x:y:[]`的语法糖==。



> 对Tuple和List的绑定，最外面都是括号。
>
> - Tuple，内部以`,`分隔
> - List，内部以`:`分隔，并追加`[]`





# Guards

```haskell
bmiTell :: (RealFloat a) => a -> a -> String
bmiTell weight height
| weight / height ^ 2 <= 18.5 = "You're underweight, you emo, you!"
| weight / height ^ 2 <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"
| weight / height ^ 2 <= 30.0 = "You're fat! Lose some weight, fatty!"
| otherwise = "You're a whale, congratulations!"
```



# where关键字

```haskell
bmiTell :: (RealFloat a) => a -> a -> String
bmiTell weight height
| weight / height ^ 2 <= 18.5 = "You're underweight, you emo, you!"
| weight / height ^ 2 <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"
| weight / height ^ 2 <= 30.0 = "You're fat! Lose some weight, fatty!"
| otherwise = "You're a whale, congratulations!"
```

在where中声明的名字，对每个Guard都可见。



在where中定义函数：

```haskell
calcBmis :: (RealFloat a) => [(a, a)] -> [a]  
calcBmis xs = [bmi w h | (w, h) <- xs]
    where bmi weight height = weight / height ^ 2
```





# Let表达式

语法为：`let [bindings] in [expressions]`

>let 绑定本身是个表达式，而 where 绑定则是个语法结构。



let不仅可以声明名字，也可以声明函数。

```haxe
ghci> (let (a,b,c) = (1,2,3) in a+b+c) * 100
60
```

```haxe
ghci> [let square x = x * x in (square 5, square 3, square 2)]  
[(25,9,4)] 
```



let还可以用在List Comprehension中：

```haxe
calcBmis :: (RealFloat a) => [(a, a)] -> [a]
calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2]
```



# case表达式

> ==模式匹配本质上是 case 表达式的语法糖==。



case表达式的语法：

```haskell
case expression of pattern -> result  
                   pattern -> result  
                   pattern -> result  
                   ...
```



如下两端源代码是等价的：

```haxe
head' :: [a] -> a  
head' [] = error "No head for empty lists!"
head' (x:_) = x 
```

```haxe
head' :: [a] -> a  
head' xs = case xs of [] -> error "No head for empty lists!"
                      (x:_) -> x 
```



==函数参数的模式匹配只能在定义函数时使用，而 case 表达式可以用在 任何地方==。

如下两端代码也是等价的：

```haskell
describeList :: [a] -> String
describeList xs =
  "The list is "
    ++ case xs of
      [] -> "empty"
      [x] -> "sigle"
      xs -> "a longer list"
```

```haskell
describeList :: [a] -> String
describeList xs =
  "The list is " ++ what xs
  where
    what [] = "empty"
    what [x] = "sigle"
    what xs = "a longer list"
```


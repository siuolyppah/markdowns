# 虚函数

- 使用关键字`virtual`定义虚函数
- ==任何构造函数之外的非静态函数，都可以定义为虚函数==。
- ==通过指针或引用，调用虚函数，将引发运行时多态==。
- ==virtual关键字，只能出现在类内部的声明语句之前==。而不能用于类外部的定义。
- ==基类总应该定义虚析构函数==。
- ==如果基类把一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数==。

- ==非虚构函数的解析过程，发生在编译时==。



```C++
class A
{
public:
    void foo()
    {
        cout << "A:foo()" << endl;
    }

    virtual void vfoo1()
    {
        cout << "A:vfoo1()" << endl;
    }

    virtual void vfoo2()
    {
        cout << "A:vfoo2()" << endl;
    }
};

class B : public A
{
public:
    virtual void vfoo2()
    {
        cout << "B:vfoo2()" << endl;
    }
};

int main()
{
    A &&a = B();
    
    a.foo();
    a.vfoo1();
    a.vfoo2();

    return 0;
}
```



# vptr和vtbl

>- vptr：虚指针
>- vtbl：虚表
>
>> 都是代码层面所观察不到的，由编译器为实现对象模型而添加的

![image-20220908123107686](%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20220908123107686.png)

![image-20220908123112765](%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20220908123112765.png)

> 在继承体系中，非虚函数只存在一个。
>
> 但虚函数每次被重写，都将生成新函数，并更新本类的虚函数表。





当**类中存在虚函数时**，该类的对象需要存储：

- 数据部分

- **还需要存储一个指针vptr**，指向该类的虚表vtbl。

  > 在tbl中，存储着该类的虚函数，对应的地址。

  > 在Java中，类的方法都是虚函数。
  >
  > 而在C++中，需要使用关键字virtual指明。





💡总结：关于方法：

- 非虚方法：
  - 子类有该方法（考虑继承权限）
  - **通过静态绑定调用**
- 虚方法：
  - 子类有该方法（考虑继承权限）
  - **通过动态绑定调用**，利用vptr和vtbl实现

例如：

```C++
base* b = new derived();
b->vfun();
b->fun();
```

其中：

- vfun()
  - 是一个虚函数，方法的调用通过动态绑定确定
  - 将调用derived类的vfun()方法，若derived类未重写该方法，将使用从base类继承下来的方法。
- fun()
  - 是一个非虚函数，方法的调用通过静态绑定
  - 将调用指针b所对应类型base的fun()方法。



# 访问控制与继承

- ==派生类会继承定义在基类中的成员，但派生类的成员函数不一定有权访问==。



# 关于类声明的问题

- 派生类的声明：

  ```C++
  class B: public class A;	// error
  class B;	// ok
  ```

  > 声明语句的目的，是为了让程序知晓某个标识符的存在，以及它表示什么样的实体（变量、类、函数等）。

- ==被用作基类的类，必须已经定义，而非只是声明==。



# final阻止继承

```C++
class NODerived final{
    /**/
}
```



# 回避虚函数

```C++
double x = base->A::foo();
```

强制使用类A的虚函数foo()，该调用将在编译时完成解析。




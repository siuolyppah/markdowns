# C++的内存区域划分

- 堆
- 栈
- （全局/局部）静态存储区
- 常量存储区



# 智能指针

C++11中，提供了如下的智能指针，用于自动释放其所指向的对象：

- `shared_ptr`：

  允许多个指针，指向同一对象。

- `unique_ptr`：

  独占所指向的对象。

- `weak_ptr`：

  是一种弱引用，指向shared_ptr所管理的对象。





# 使用动态内存的原因

- 程序不知道自己需要使用多少对象。如容器类。
- 程序不知道所需对象的准确类型。
- 程序需要在多个对象中共享数据。



# shared_ptr\<T>

## make_shared\<T>()

```c++
shared_ptr<string> p = make_shared<string>("hel");

{
    shared_ptr<string> p1 = p;
    cout << p.use_count() << endl;
    cout << p.unique() << endl;
}

cout << p.use_count() << endl;
cout << p.unique() << endl;
```



## 与new结合使用

![image-20220906154821242](%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/image-20220906154821242.png)



## 使用自定义的释放操作

> review：
>
> 默认情况下，shared_ptr管理的是动态内存，默认地使用析构函数释放对象。



==对于那些为C和C++两种语言设计的类，通常都要求用户显式的释放资源==。

> 即不使用析构函数释放资源。

可以shared_ptr管理这种类（即哑类）。只要在构造shared_ptr对象时，传递一个函数指针，该函数接收一个对应类型的指针。



```C++
struct A
{
    char *name;

    A()
    {
        name = new char[10];
        cout << "A()" <<endl;
    }
};

void freeA(A *a)
{
    delete[] a->name;
    cout << "freeA()" <<endl;
}

int main()
{
    {
        shared_ptr<A> sp(new A(), &freeA);
    }

    return 0;
}
```



## 智能指针陷阱

1. 不要使用相同的内置指针的值，初始化或reset多个智能指针。

2. 不要对通过调用智能指针的get()返回的指针值，进行手动delete。

3. 不要使用get()初始化或reset另一个智能指针。

   > 因为这会导致两个智能指针分别管理它们的引用计数器。



# unique_ptr\<T>

一个unique_ptr“拥有”它所指向的对象。==当unique_ptr被销毁时，它所指向的对象也被销毁==。



![image-20220906165348795](%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/image-20220906165348795.png)



==unique_ptr，不支持复制构造和复制赋值，但支持移动构造和移动赋值==。



>- 向unique_ptr传递删除器时，与shared_ptr有所不同。
>
>  参见P419



## 管理动态数组

```C++
unique_ptr<int[]> up(new int[10]);
up.release();	// 自动用delete[]销毁其指针
```

==指向数组的unique_ptr不能使用`.`和`->`成员运算符，但可以使用下标来访问元素==：

```C++
for(size_t i=0; i != 10; ++i){
    up[i] = i;
}
```

![image-20220906172347071](%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/image-20220906172347071.png)



shared_pt不直接支持管理动态数组，需要提供删除器：
```C++
shared_ptr<int> sp(new int[10], [](int* p){delete[] p;});
sp.reset();		// 用提供的lambda释放数组
```

```C++
for(size_t i=0; i != 10; ++i){
	*(sp.get() + i) = i;
}
```







# weak_ptr\<T>

weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。==将一个weak_ptr绑定到一个shared_ptr，并不会改变shared_ptr的引用计数==。

> 即一旦最后一个指向对象的shared_ptr被销毁，则无论是否有weak_ptr指向对象，对象仍会被销毁。



![image-20220906170356127](%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/image-20220906170356127.png)



```C++
shared_ptr<int> p = make_shared<int>();
weak_ptr<int> wp {p};

if (shared_ptr<int> np = wp.lock()) 
{
    // 如果np不为空则条件成立
}
// else，wp所引用的对象已经被释放
```



# allocator类

用于将内存分配和对象构造分离。

![image-20220906174744025](%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/image-20220906174744025.png)



为了定义一个allocator对象，必须指明allocator可以分配的对象类型。

他==会根据给定的对象类型，来确定恰当的内存大小和对齐位置==：

```C++
size_t n = 3;
std::allocator<string> alloc;
string *const p = alloc.allocate(n);
```



allocator分配的内存是未构造的，需要调用`construct()`构造对象：

```C++
auto q = p;	// q指向最后构造的元素之后的位置
alloc.construct(q++);			// *q为空串
alloc.construct(q++,10,'c'); 	// *q为"cccccccccc"
alloc.construct(q++,"hi");		// *q为"hi"
```



当用完对象后，必须对每个构造的对象调用`destroy()`来销毁它们：

```C++
while(q != p){
    alloc.destroy(--q);
}
```



当元素被销毁后，可以选择通过调用`deallocate()`将内存归还系统：

```C++
alloc.deallocate(p,n);
```



## 拷贝和填充未初始化内存的算法

标准库为allocator类，定义了两个伴随算法，用于在未初始化内存中创建对象。

![image-20220906175140807](%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/image-20220906175140807.png)



```C++
vector<int> vi{0, 1, 2, 3, 4, 5};

allocator<int> alloc;
int *p = alloc.allocate(vi.size());
// 在p位置开始，拷贝vi中的元素。返回最后一个元素的指针
int *q = uninitialized_copy(vi.begin(), vi.end(), p);
// 在q位置，使用魔数42填充vi.size()次
uninitialized_fill_n(q, vi.size(), 42);
```


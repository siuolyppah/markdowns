# 栈展开

即沿着调用链，反向查找catch块的过程。



- 栈展开过程中，会自动销毁自动对象。
- ==析构函数总是被执行，但负责释放资源的代码可能被跳过==。



# std::terminate()

若找不到匹配的catch块，则程序将调用`std::terminate()`终止程序运行。



# 异常对象

- 异常抛出表达式抛出的对象，使用拷贝初始化。
  - 如果是类类型，则需要相应的类必须含有一个可访问的析构函数、一个可访问的复制或移动构造函数。
  - 如果是数组类型或函数类型，则表达式将其转换对应的指针类型。



# 函数try块

在进入构造函数之前，将首先执行初始值列表。

若在初始值列表中抛出异常，由于此时函数体还未被执行，因此无法被捕获。

此时需要函数try块（function try block)：

```C++
template<typename T>
Blob<T>::blob(std::initializer_list<T> il) 
    try: data(std::make_shared<std::vector<T>>){

    }catch(const std::bad_alloc &e){
        handle_out_of_memory(e);
    }
```



# noexcept异常说明

通过`noexcept`说明符，可指定某个函数不会抛出异常。



违反异常说明：
即便声明了`noexcept`,仍可抛出异常，并通过编译。

```C++
void f() noexcept{
    throw 1;
}
```

==一旦一个noexcept函数抛出异常，程序就会调用terminate()==。



使用noexcept的两种情况：

1. 确定函数不会抛出异常
2. 根本不知道如何处理异常



noexcept接收一个可选的实参，该参数必须能转换为bool类型：
```C++
void recoup(int) noexcept(true);	// recoup不会抛出异常
void alloc(int) noexcept(false);	// alloc可能抛出异常
```



noexcept运算符：其返回一个bool类型的常量表达式。

```C++
noexcept(recoup(1));	//true
```

更一般的形式如下：仅当e调用的所有函数都声明为noexcept，并且e没有throw异常时，该表达式为真。

```C++
noexcept(e);	
```



也就是说，noexcept有两层含义：

1. 出现在函数参数列表后，它是一个异常说明符；
2. 当bool实参出现时，它是一个运算符。





# 异常类层次

18.1.5
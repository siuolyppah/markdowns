# 函数模板定义的语法

```cpp
template<typename T>
int compare(const T& v1, const T& v2){
    return v1 < v2;
}
```

其中，`<>`及其内部为模板参数列表，其包含一个或多个==模板参数==。

模板参数表示在类或函数定义中，用到的==类型或值==。

> 当使用模板时，需要隐式或显式的指定模板实参。





# 非类型的模板参数

除了定义类型参数，还可以在模板中定义非类型参数。

- ==一个非类型参数，表示一个值而非类型==。

- 当一个模板被实例化时，非类型参数被用户提供的，或编译器推断出的值代替。

  ==这些值必须是常量表达式==，从而允许编译器在编译时将模板实例化。

- 在模板定义内部，模板非类型参数是一个常量值，可以出现在任意需要常量表达式的地方。



```C++
template<unsigned N,unsigned M>
int compare(const char(&p1)[N],const char(&p2)[M]){
    return strcmp(p1,p2);
}

cout << compare("hello","world");
```



非类型参数，可以是：

1. 整形
2. 指向对象或函数的指针
3. （左值）引用



# 模板需要实现在头文件中

> review：
>
> - 类定义、函数声明放在头文件；
> - 类的成员函数定义、函数定义放在源文件。



为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。

因此，==模板的头文件通常既包含声明又包含定义==。





# 类模板

- 需要手动在模板参数列表提供额外信息。

  > 函数模板可以自动推导。



# 类型成员

假设T是一个模板类型参数，当编译器遇到类似`T::mem`的代码，编译器无法推测mem是一个类型成员，还是一个static的数据成员。



==在默认情况下，C++语言假定通过作用域运算符`::`，访问的是名字而非类型==。

==因此，如果希望使用一个模板类型参数的类型成员，就必须使用`typename`关键字，告诉编译器这是一个类型==。



```C++
template<typename T>
typename T::value_type top(const T& c){
    if(!c.empty()){
        return c.back();
    }
    else{
        return typename T::value_type();
    }
}
```




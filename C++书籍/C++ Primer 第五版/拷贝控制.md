# 拷贝构造函数

- 拷贝构造函数的要求：

  - 第一个参数是自身类类型的引用；

    > 否则，设想如下情况：
    >
    > 为了调用拷贝构造函数，必须先拷贝它的实参；而为了拷贝它的实参，又需要调用拷贝构造函数，如此无限循环。

  - ==任何额外参数都提供默认值==。

  ```C++
  class A{
    A(cosnt A& a,int x=0,int y=0);
  };
  ```



# 直接初始化与拷贝初始化

> review：
>
> - 值初始化：强调的是初始化时，给了初始值
> - 默认初始化：强调的是没有给定初始值，使用的默认构造函数（内建类型为野值）。

- 直接初始化：

  要求编译器使用普通的==函数匹配==，来选择与我们提供的参数最匹配的构造函数。

- 拷贝初始化：

  要求编译器将右侧运算对象，拷贝到当前正则创建的对象中。并==在需要时进行类型转换==。



==拷贝初始化发生时，将使用拷贝构造函数或移动构造函数==。

拷贝初始化发生的情况：

1. 使用`=`定义变量；
2. 将一个对象，作为实参传递给一个非引用类型的形参；
3. 从一个返回类型为非引用类型的函数，返回一个对象；
4. 用花括号列表初始化一个数组中的元素，或一个聚合类中的成员。



# 三/五法则

1. ### 需要析构函数的类，也需要拷贝和赋值操作

2. ### 需要拷贝操作的类，也需要赋值操作，反之亦然

3. ### 析构函数不能是删除的

4. ### 如果一个类成员有删除的或不可访问的析构函数，那么其默认和拷贝构造函数会被定义为删除的。

5. ### ==合成的拷贝控制成员可能是删除的==。

   > 1. 类的合成析构函数被定义为删除的：
   >
   >    若类的某个成员的析构函数，是删除的或不可访问的(如private)，则
   >
   > 2. 类的合成拷贝构造函数被定义为删除的：
   >
   >    若类的某个成员的拷贝构造函数是删除的或不可访问的；
   >
   >    或类的某个成员的析构函数是删除的或不可访问的；
   >
   > 3. 类的合成赋值运算符被定义为删除的：
   >
   >    若类型的某个成员的拷贝赋值运算符是删除的或不可访问的；
   >
   >    或类有一个const的或引用成员
   >
   > 4. 类的默认构造函数被定义为删除的：
   >
   >    类的某个成员的析构函数是删除的或不可访问的；
   >
   >    类有一个引用成员，它没有类内初始值（in-class initializer）；
   >
   >    类有一个const成员，它没有类内初始值，且其类型未显式定义默认构造函数。



# 控制默认行为

## =default

- 若定义在类内，则合成的函数将被隐式地声明为内联的。
- 若定义在类外，则合成的函数将不是内联的。

- 只有默认构造函数或拷贝控制成员，能被定义为=default的。



## =delete

- 必须出现在函数==第一次<u>声明</u>处==。
- 任何函数，都可指定=delete。





# 设计引用计数

> 参见P455



```Cpp
#include <iostream>

using namespace std;

template <class T>
class my_shared_ptr
{
public:
    my_shared_ptr(T *elem)
        : _elem(elem), _use(new std::size_t{0})
    {
    }

    my_shared_ptr(const my_shared_ptr &other)
        : _elem(other._elem), _use(other._use)
    {
        ++*_use;
    }

    my_shared_ptr(my_shared_ptr &&other)
        : _elem(other._elem), _use(other._use)
    {
        ++*_use;
    }

    ~my_shared_ptr()
    {
        cout << "~my_shared_ptr()" << endl;
        --*_use;

        if (!*_use)
        {
            delete _use;
            delete _elem;
        }
    }

    my_shared_ptr &operator=(my_shared_ptr &other)
    {

        // 考虑自赋值
        ++other._use;
        if (!(--this->_use))
        {
            delete this->T;
        }

        this->_use = other._use;
    }

    std::size_t use_count()
    {
        return *_use;
    }

    bool unique()
    {
        return *_use;
    }

    T operator*()
    {
        return *_elem;
    }

private:
    T *_elem;
    std::size_t *_use;
};

my_shared_ptr<int> foo()
{
    auto msp = my_shared_ptr<int>(new int{10});
    return msp;
}

int main()
{

    auto msp1 = foo();

    {
        auto msp2 = foo();
    }

    cout << *msp1 << endl;

    return 0;
}
```



# Swap操作

## 自定义swap()

```C++
class HasPtr{
	friend void swap(HasPtr&, HasPtr&);
    // 其他成员省略，主要的属性：string*, int
};

inline
void swap(HasPtr &lhs, HasPtr &rhs){
    using std::swap;
    swap(lhs.ps, rhs.ps);		// 交换string指针，而非string
    swap(lhs.i, rhs.i);			// 交换int成员
}
```

>注意点：
>
>在自定义的swap()中：
>
>1. 引入std::swap()
>2. 但在每个调用时，都是未加限定的swap()。
>
>> 因为特定类型的swap()，会优于std::swap()。



## 在赋值操作中使用copy and swap

如果类中定义了swap()操作，则其赋值操作，可定义为类似如下形式：

```C++
// 注意rhs是按值传递的，意味着将调用HasPtr的拷贝构造函数
HasPtr& Has::operator=(HasPtr rhs){
    swap(*this,rhs);	// this现在的内容，指向了形参rhs的内容
    return *this;
}
```

> 注意：
>
> 形参rhs不是一个引用。即进行了Copy。



使用copy and swap，显然就是异常安全的，而且能处理自赋值。



# 移动迭代器

> 一般来说，一个迭代器的解引用运算符返回一个指向元素的左值。

通过调用标准库的`make_move_iterator`函数，可以将一个普通迭代器转换为一个移动迭代器。



# 限定this

```C++
string s1 = "a", s2 = "b";
s1 + s2 = "fafa";
```

在上述代码中，s1+s2的结果是一个右值，并对其进行了赋值。（正确）

> 在新标准中，仍允许向右值赋值。



但允许像限定this为const一样，可以将this限定为左值或右值：

```C++
class Foo{
public:
    Foo& operator=(const Foo&) &;	// 限定this为左值；
};
```




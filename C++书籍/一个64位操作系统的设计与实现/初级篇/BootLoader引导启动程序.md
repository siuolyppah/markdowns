BootLoader引导启动程序原本由Boot引导程序和Loader引导加载程序两部分构成。

1. Boot引导程序主要负责开机启动和加载Loader程序；
2. Loader引导加载程序则用于完成配置硬件工作环境、引导加载内核等任务。



# Boot引导程序

计算机上电之后：

1. BIOS自检；

2. 若检测无误，根据BIOS的启动项配置，选择引导设备。

   > 目前BIOS支持的设备启动项，有：
   >
   > - 软盘启动
   > - U盘启动（最为简单，本系统采用）
   > - 硬盘启动（默认情况）
   > - 网络启动



## BIOS引导原理

> 当BIOS自检结束后，会根据启动项设置（此处为软驱启动），去选择启动设备。

即检测软盘的==第0磁头第0磁道第1扇区==，是否以数值0x55和0xaa两字节作为结尾。

如果是，那么BIOS就认为这个扇区是一个Boot Sector（引导扇区），进而==把此扇区的数据复制到物理内存地址0x7c00处，随后将处理器的执行权移交给这段程序（跳转至0x7c00地址处执行）==。



软盘的磁盘结构图：

<img src="BootLoader%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F.assets/epub_26211970_12.jpeg" alt="epub_26211970_12" style="zoom: 33%;" />



对于一张3.5英寸的1.44MB软盘而言，一个扇区的容量仅有512 B，而且BIOS只负责加载这一个扇区的数据到物理内存中，一个容量只有512 B的引导扇区是无法容纳操作系统的，甚至连获取硬件信息的检测程序都容纳不下。

鉴于如此苛刻的容量限制，Boot引导程序仅能作为一级助推器，将功能更强大的引导加载程序Loader装载到内存中，这也可以看做是硬件设备向软件移交控制权。一旦Loader引导加载程序开始执行，那么一切都交由我们编写的软件来控制。



引导扇区里的程序自然应该叫作引导程序。在BIOS向引导程序移交执行权之前，BIOS会对处理器进行初始化，这其中就包括处理器的代码段寄存器CS和指令指针寄存器IP。当BIOS跳转至引导程序时，CS寄存器和IP寄存器的值分别为0x0000和0x7c00。此时的处理器正处于实模式下，物理地址必须经过CS寄存器和IP寄存器转换才能得到，转换公式为：物理地址= CS << 4 + IP，也就是物理地址0x7c00处。



## Boot引导程序

>在开机的一瞬间，也就是接电的一瞬间， CPU 的 CS: ip 寄存器被强制初始化为0xF000:0xFFF0。由于开机的时候处于实模式，在实模式下的段基址要乘以 16，也就是左移4位，于是 0xF000:0xFFF0 的等效地址将是 0xFFFF0 。



boot.asm（NASM，Intel汇编语言格式）：

```nasm
	org	0x7c00	

BaseOfStack	equ	0x7c00

Label_Start:

	mov	ax,	cs
	mov	ds,	ax
	mov	es,	ax
	mov	ss,	ax
	mov	sp,	BaseOfStack

;=======	clear screen

	mov	ax,	0600h
	mov	bx,	0700h
	mov	cx,	0
	mov	dx,	0184fh
	int	10h

;=======	set focus

	mov	ax,	0200h
	mov	bx,	0000h
	mov	dx,	0000h
	int	10h

;=======	display on screen : Start Booting......

	mov	ax,	1301h
	mov	bx,	000fh
	mov	dx,	0000h
	mov	cx,	10
	push	ax
	mov	ax,	ds
	mov	es,	ax
	pop	ax
	mov	bp,	StartBootMessage
	int	10h

;=======	reset floppy

	xor	ah,	ah
	xor	dl,	dl
	int	13h

	jmp	$

StartBootMessage:	db	"Start Boot"

;=======	fill zero until whole sector

	times	510 - ($ - $$)	db	0
	dw	0xaa55
```

它的功能并不复杂，只为在屏幕上显示一条日志信息。



在这段程序中，org是Origin的英文缩写，意思为起始地址或源地址。==这条伪指令用于指定程序的起始地址==，若程序未使用org伪指令，那么编译器会把地址0x0000作为程序的起始地址。==程序的起始地址将主要影响绝对地址寻址指令==，不同的起始地址会编译生成不同的绝对地址。

因此，代码org 0x7c00的意思是，将程序的起始地址设置在0x7c00处。至于为什么是0x7c00，想必只有当年的BIOS工程师们才会知道。既然BIOS会加载引导程序至内存地址0x7c00处，我们就必须将引导程序的起始地址设置在此处，否则当程序访问绝对地址时很可能会出错。



汇编代码BaseOfStack equ 0x7c00，这是一条等价语句，它将标识符BaseOfStack等价为数值0x7c00。

其中，equ伪指令的作用是，让其左边的标识符代表右边的表达式。equ等价语句不会给标识符分配存储空间，而且标识符不能与其他符号同名，也不能被重新定义。

equ不光可以代表常量和表达式，也可以代表字符串以及一些助记符。



代码mov sp, BaseOfStack中，标识符BaseOfStack用于为栈指针寄存器SP提供栈基址。





## 创建虚拟软盘镜像文件

````
[gxy@arch myos]$ bximage
========================================================================
                                bximage
  Disk Image Creation / Conversion / Resize and Commit Tool for Bochs
         $Id: bximage.cc 14091 2021-01-30 17:37:42Z sshwarts $
========================================================================

1. Create new floppy or hard disk image
2. Convert hard disk image to other format (mode)
3. Resize hard disk image
4. Commit 'undoable' redolog to base image
5. Disk image info

0. Quit

Please choose one [0] 5

Disk image info

What is the name of the image?
[c.img] boot.img

disk image mode = 'flat'
hd_size: 1474560
geometry = 2/16/63 (1 MB)
````



## 编译boot.asm

```sh
nasm boot.asm -o boot.bin
```



## 将引导程序写入虚拟软盘的固定扇区

```sh
dd if=boot.bin of=boot.img bs=512 count=1 conv=notrunc
```

if指定源文件名，of指定输出文件，bs指定传输的块大小，count指定写入到目标文件的块数量。



## 启动bochs

```sh
bochs
```



启动后是一个黑框：

<img src="BootLoader%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F.assets/image-20220909165900488.png" alt="image-20220909165900488" style="zoom:33%;" />



>在终端命令行中输入字符串c/cont/continue中的任意一种，即可使虚拟机运行。

![image-20220909165932021](BootLoader%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F.assets/image-20220909165932021.png)





>.bochsrc如下：
>```
># configuration file generated by Bochs
>plugin_ctrl: unmapped=1, biosdev=1, speaker=1, extfpuirq=1, parallel=1, serial=1, iodebug=1
>config_interface: textconfig
>display_library: x
>
>romimage: file=/usr/local/share/bochs/BIOS-bochs-latest
>vgaromimage: file=/usr/local/share/bochs/VGABIOS-lgpl-latest
> 
>#设置启动盘符
>boot: floppy
>floppya: type=1_44, 1_44="boot.img", status=inserted, write_protected=0
>
>ata0-master: type=none
>ata0-slave: type=none
>ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
>ata1-master: type=none
>ata1-slave: type=none
>ata2: enabled=0
>ata3: enabled=0
>pci: enabled=1, chipset=i440fx
>vga: extension=vbe, update_freq=5
>
>#设置日志文件的输出
>log: bochs.out
> 
>print_timestamps: enabled=0
>debugger_log: -
>magic_break: enabled=0
>port_e9_hack: enabled=0
>private_colormap: enabled=0
>clock: sync=none, time0=local, rtc_sync=0
>
>log: -
>logprefix: %t%e%d
>debug: action=ignore
>info: action=report
>error: action=report
>panic: action=ask
>keyboard: type=mf, serial_delay=250, paste_delay=100000, user_shortcut=none
>mouse: type=ps2, enabled=0, toggle=ctrl+mbutton
>speaker: enabled=1, mode=system
>parport1: enabled=1, file=none
>parport2: enabled=0
>com1: enabled=1, mode=null
>com2: enabled=0
>com3: enabled=0
>com4: enabled=0
>
>megs: 2048
>```





## 加载Loader到内存

> 在MBR的基础上，加入文件加载功能，即可完成Boot引导程序的工作。

说到加载Loader程序，最理想的方法自然是从文件系统中把Loader程序加载到内存里。考虑到代码的易实现性，本操作系统将选用逻辑简单的FAT12文件系统来装载Loader程序和内核程序。



在将软盘格式化成FAT12文件系统的过程中，FAT类文件系统会对软盘里的扇区进行结构化处理，进而把==软盘扇区划分成：引导扇区、FAT表、根目录区和数据区4部分==。

- 引导扇区：

  - FAT12文件系统的引导扇区不仅包含有引导程序，还有FAT12文件系统的整个组成结构信息。这些信息描述了FAT12文件系统对磁盘扇区的管理情况，它相当于EXT类文件系统的superblock结构，但是与EXT类文件系统相比，FAT类文件系统的结构更简单、易于实现。

    FAT12文件系统的引导扇区结构如下：

    ![img](BootLoader%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F.assets/epub_26211970_15.jpeg)

    - 在引导程序的起始处，首先定义的是BS_jmpBoot字段。从字面意思可知，它是一句跳转代码，这是由于BS_jmpBoot字段后面的数据不是可执行程序，而是FAT12文件系统的组成结构信息，故此必须跳过这部分内容。
    - BS_OEMName。记录制造商的名字，亦可自行为文件系统命名。
    - BPB_SecPerClus。描述了每簇扇区数。由于每个扇区的容量只有512 B，过小的扇区容量可能会导致软盘读写次数过于频繁，从而引入簇（Cluster）这个概念。簇将2的整数次方个扇区作为一个“原子”数据存储单元，也就是说==簇是FAT类文件系统的最小数据存储单位==。
    - BPB_RsvdSecCnt。指定保留扇区的数量，此域值不能为0。保留扇区起始于FAT12文件系统的第一个扇区，对于FAT12而言此位必须为1，也就意味着引导扇区包含在保留扇区内，所以==FAT表从软盘的第二个扇区开始==。
    - BPB_NumFATs。指定FAT12文件系统中FAT表的份数，任何FAT类文件系统都建议此域设置为2。设置为2主要是为了给FAT表准备一个备份表，因此FAT表1与FAT表2内的数据是一样的，FAT表2是FAT表1的数据备份表。
    - BPB_RootEntCnt。指定根目录可容纳的目录项数。对于FAT12文件系统而言，这个数值乘以32必须是BPB_BytesPerSec的偶数倍。
    - BPB_TotSec16。记录着总扇区数。这里的总扇区数包括保留扇区（内含引导扇区）、FAT表、根目录区以及数据区占用的全部扇区数，如果此域值为0，那么BPB_TotSec32字段必须是非0值。
    - BPB_Media。描述存储介质类型。对于不可移动的存储介质而言，标准值是0xF8。对于可移动的存储介质，常用值为0xF0，此域的合法值是0xF0、0xF8、0xF9、0xFA、0xFB、0xFC、0xFD、0xFE、0xFF。另外提醒一点，无论该字段写入了什么数值，同时也必须向FAT[0]的低字节写入相同值。
    - BPB_FATSz16。记录着FAT表占用的扇区数。FAT表1和FAT表2拥有相同的容量，它们的容量均由此值记录。
    - BS_VolLab。指定卷标。它就是Windows或Linux系统中显示的磁盘名。
    - BS_FileSysType。描述文件系统类型。此处的文件系统类型值为’FAT12 '，这个类型值只是一个字符串而已，操作系统并不使用该字段来鉴别FAT类文件系统的类型。

    据此，可将软盘扇区描绘成如下结构：

    ![img](BootLoader%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F.assets/epub_26211970_16.jpeg)

- FAT表：

  FAT12文件系统以簇为单位来分配数据区的存储空间（扇区），每个簇的长度为`BPB_BytesPerSec * BPB_SecPerClus`字节，数据区的簇号与FAT表的表项是一一对应关系。

  因此，文件在FAT类文件系统的存储单位是簇，而非字节或扇区，即使文件的长度只有一个字节，FAT12文件系统也会为它分配一个簇的磁盘存储空间。此种设计方法可以将磁盘存储空间按固定存储片（页）有效管理起来，进而可以按照文件偏移，分片段访问文件内的数据，就不必一次将文件里的数据全部读取出来。

  FAT表中的表项位宽与FAT类型有关，例如，FAT12文件系统的表项位宽为12 bit、FAT16文件系统的表项位宽为16 bit、FAT32文件系统的表项位宽为32 bit。

  FAT表项取值说明：

  ![epub_26211970_17](BootLoader%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F.assets/epub_26211970_17.jpeg)

- 根目录区和数据区：

  从本质上讲，根目录区和数据区都保存着与文件相关的数据，只不过根目录区只能保存目录项信息，而数据区不但可以保存目录项信息，还可以保存文件内的数据。

  此处提及的目录项是一个由32 B组成的结构体，它既可以表示成一个目录，又可以表示成一个文件，其中记录着名字、长度以及数据起始簇号等信息。

  ![epub_26211970_18](BootLoader%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F.assets/epub_26211970_18.jpeg)

  

## loader.asm

```asm
;/***************************************************
;		版权声明
;
;	本操作系统名为：MINE
;	该操作系统未经授权不得以盈利或非盈利为目的进行开发，
;	只允许个人学习以及公开交流使用
;
;	代码最终所有权及解释权归田宇所有；
;
;	本模块作者：	田宇
;	EMail:		345538255@qq.com
;
;
;***************************************************/

org	10000h

	mov	ax,	cs
	mov	ds,	ax
	mov	es,	ax
	mov	ax,	0x00
	mov	ss,	ax
	mov	sp,	0x7c00

;=======	display on screen : Start Loader......

	mov	ax,	1301h
	mov	bx,	000fh
	mov	dx,	0200h		;row 2
	mov	cx,	12
	push	ax
	mov	ax,	ds
	mov	es,	ax
	pop	ax
	mov	bp,	StartLoaderMessage
	int	10h

	jmp	$

;=======	display messages

StartLoaderMessage:	db	"Start Loader"
```



```sh
```


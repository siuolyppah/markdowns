BootLoader引导启动程序原本由Boot引导程序和Loader引导加载程序两部分构成。

1. Boot引导程序主要负责开机启动和加载Loader程序；
2. Loader引导加载程序则用于完成配置硬件工作环境、引导加载内核等任务。



# Boot引导程序

计算机上电之后：

1. BIOS自检；

2. 若检测无误，根据BIOS的启动项配置，选择引导设备。

   > 目前BIOS支持的设备启动项，有：
   >
   > - 软盘启动
   > - U盘启动（最为简单，本系统采用）
   > - 硬盘启动（默认情况）
   > - 网络启动



## BIOS引导原理

> 当BIOS自检结束后，会根据启动项设置（此处为软驱启动），去选择启动设备。

即检测软盘的==第0磁头第0磁道第1扇区==，是否以数值0x55和0xaa两字节作为结尾。

如果是，那么BIOS就认为这个扇区是一个Boot Sector（引导扇区），进而==把此扇区的数据复制到物理内存地址0x7c00处，随后将处理器的执行权移交给这段程序（跳转至0x7c00地址处执行）==。



软盘的磁盘结构图：

<img src="BootLoader%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F.assets/epub_26211970_12.jpeg" alt="epub_26211970_12" style="zoom: 33%;" />



对于一张3.5英寸的1.44MB软盘而言，一个扇区的容量仅有512 B，而且BIOS只负责加载这一个扇区的数据到物理内存中，一个容量只有512 B的引导扇区是无法容纳操作系统的，甚至连获取硬件信息的检测程序都容纳不下。

鉴于如此苛刻的容量限制，Boot引导程序仅能作为一级助推器，将功能更强大的引导加载程序Loader装载到内存中，这也可以看做是硬件设备向软件移交控制权。一旦Loader引导加载程序开始执行，那么一切都交由我们编写的软件来控制。



引导扇区里的程序自然应该叫作引导程序。在BIOS向引导程序移交执行权之前，BIOS会对处理器进行初始化，这其中就包括处理器的代码段寄存器CS和指令指针寄存器IP。当BIOS跳转至引导程序时，CS寄存器和IP寄存器的值分别为0x0000和0x7c00。此时的处理器正处于实模式下，物理地址必须经过CS寄存器和IP寄存器转换才能得到，转换公式为：物理地址= CS << 4 + IP，也就是物理地址0x7c00处。



## Boot引导程序

>在开机的一瞬间，也就是接电的一瞬间， CPU 的 CS: ip 寄存器被强制初始化为0xF000:0xFFF0。由于开机的时候处于实模式，在实模式下的段基址要乘以 16，也就是左移4位，于是 0xF000:0xFFF0 的等效地址将是 0xFFFF0 。



boot.asm（NASM，Intel汇编语言格式）：

```nasm
	org	0x7c00	

BaseOfStack	equ	0x7c00

Label_Start:

	mov	ax,	cs
	mov	ds,	ax
	mov	es,	ax
	mov	ss,	ax
	mov	sp,	BaseOfStack

;=======	clear screen

	mov	ax,	0600h
	mov	bx,	0700h
	mov	cx,	0
	mov	dx,	0184fh
	int	10h

;=======	set focus

	mov	ax,	0200h
	mov	bx,	0000h
	mov	dx,	0000h
	int	10h

;=======	display on screen : Start Booting......

	mov	ax,	1301h
	mov	bx,	000fh
	mov	dx,	0000h
	mov	cx,	10
	push	ax
	mov	ax,	ds
	mov	es,	ax
	pop	ax
	mov	bp,	StartBootMessage
	int	10h

;=======	reset floppy

	xor	ah,	ah
	xor	dl,	dl
	int	13h

	jmp	$

StartBootMessage:	db	"Start Boot"

;=======	fill zero until whole sector

	times	510 - ($ - $$)	db	0
	dw	0xaa55
```

它的功能并不复杂，只为在屏幕上显示一条日志信息。



在这段程序中，org是Origin的英文缩写，意思为起始地址或源地址。==这条伪指令用于指定程序的起始地址==，若程序未使用org伪指令，那么编译器会把地址0x0000作为程序的起始地址。==程序的起始地址将主要影响绝对地址寻址指令==，不同的起始地址会编译生成不同的绝对地址。

因此，代码org 0x7c00的意思是，将程序的起始地址设置在0x7c00处。至于为什么是0x7c00，想必只有当年的BIOS工程师们才会知道。既然BIOS会加载引导程序至内存地址0x7c00处，我们就必须将引导程序的起始地址设置在此处，否则当程序访问绝对地址时很可能会出错。



汇编代码BaseOfStack equ 0x7c00，这是一条等价语句，它将标识符BaseOfStack等价为数值0x7c00。

其中，equ伪指令的作用是，让其左边的标识符代表右边的表达式。equ等价语句不会给标识符分配存储空间，而且标识符不能与其他符号同名，也不能被重新定义。

equ不光可以代表常量和表达式，也可以代表字符串以及一些助记符。



代码mov sp, BaseOfStack中，标识符BaseOfStack用于为栈指针寄存器SP提供栈基址。





## 创建虚拟软盘镜像文件

````
[gxy@arch myos]$ bximage
========================================================================
                                bximage
  Disk Image Creation / Conversion / Resize and Commit Tool for Bochs
         $Id: bximage.cc 14091 2021-01-30 17:37:42Z sshwarts $
========================================================================

1. Create new floppy or hard disk image
2. Convert hard disk image to other format (mode)
3. Resize hard disk image
4. Commit 'undoable' redolog to base image
5. Disk image info

0. Quit

Please choose one [0] 5

Disk image info

What is the name of the image?
[c.img] boot.img

disk image mode = 'flat'
hd_size: 1474560
geometry = 2/16/63 (1 MB)
````



## 编译boot.asm

```sh
nasm boot.asm -o boot.bin
```



## 将引导程序写入虚拟软盘的固定扇区

```sh
dd if=boot.bin of=boot.img bs=512 count=1 conv=notrunc
```

if指定源文件名，of指定输出文件，bs指定传输的块大小，count指定写入到目标文件的块数量。



## 启动bochs

```sh
bochs
```



启动后是一个黑框：

<img src="BootLoader%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F.assets/image-20220909165900488.png" alt="image-20220909165900488" style="zoom:33%;" />



>在终端命令行中输入字符串c/cont/continue中的任意一种，即可使虚拟机运行。

![image-20220909165932021](BootLoader%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F.assets/image-20220909165932021.png)





>.bochsrc如下：
>```
># configuration file generated by Bochs
>plugin_ctrl: unmapped=1, biosdev=1, speaker=1, extfpuirq=1, parallel=1, serial=1, iodebug=1
>config_interface: textconfig
>display_library: x
>
>romimage: file=/usr/local/share/bochs/BIOS-bochs-latest
>vgaromimage: file=/usr/local/share/bochs/VGABIOS-lgpl-latest
> 
>#设置启动盘符
>boot: floppy
>floppya: type=1_44, 1_44="boot.img", status=inserted, write_protected=0
>
>ata0-master: type=none
>ata0-slave: type=none
>ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
>ata1-master: type=none
>ata1-slave: type=none
>ata2: enabled=0
>ata3: enabled=0
>pci: enabled=1, chipset=i440fx
>vga: extension=vbe, update_freq=5
>
>#设置日志文件的输出
>log: bochs.out
> 
>print_timestamps: enabled=0
>debugger_log: -
>magic_break: enabled=0
>port_e9_hack: enabled=0
>private_colormap: enabled=0
>clock: sync=none, time0=local, rtc_sync=0
>
>log: -
>logprefix: %t%e%d
>debug: action=ignore
>info: action=report
>error: action=report
>panic: action=ask
>keyboard: type=mf, serial_delay=250, paste_delay=100000, user_shortcut=none
>mouse: type=ps2, enabled=0, toggle=ctrl+mbutton
>speaker: enabled=1, mode=system
>parport1: enabled=1, file=none
>parport2: enabled=0
>com1: enabled=1, mode=null
>com2: enabled=0
>com3: enabled=0
>com4: enabled=0
>
>megs: 2048
>```
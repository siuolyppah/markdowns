# 操作系统的组成结构

操作系统由内核层与应用层两部分组成。

- 内核层主要由引导启动、内存管理、异常/中断处理、进程管理、设备驱动、文件系统等模块组成，而系统API库和应用程序则属于应用层的范畴。
- 之所以将内核层和应用层分开，是因为==内核层主要负责控制硬件设备、分配系统资源、为应用层提供健全的接口支持、保证应用程序正常稳定运行等全局性工作。而应用层主要负责的是人机交互工作==。

![img](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0.assets/epub_26211970_3.jpeg)



## 引导启动（BootLoader）

引导启动是指，计算机从BIOS上电自检后到跳转至内核程序执行前这一期间执行的一段或几段程序。这些程序主要用于检测计算机硬件，并配置内核运行时所需的参数，然后再把检测信息和参数提交给内核解析，内核会在解析数据的同时对自身进行配置。

引导启动模块只是为了辅助内核启动，而并非真正属于内核。一旦内核开始执行后，引导程序便再无他用。

目前，比较流行的引导启动程序有Grub和Uboot等，它们的功能都比较强大，用户可以通过它们自带的终端命令行与之进行简单的交互，此举为控制内核的加载和使用提供了诸多便利。



## 内存管理

内存管理单元是内核的基础功能，它的主要作用是有效管理物理内存，这样可以简化其他模块开辟内存空间（连续的或非连续的）的过程，为页表映射和地址变换提供配套函数。

Linux内存管理单元的伙伴算法，算是一种稳定成熟的内存管理算法，它可以长时间保持内存的稳定分配，防止内存碎片过多。还有内存线性地址空间的红黑树管理算法，它将原有的线性地址结构转换为树状结构以缩短搜索时间，同时又在每次插入新节点时调整树的高度（或者深度），来维持树的形状进而保证搜索时间的相对稳定，该算法既兼顾搜索时间损耗又兼顾插入时间损耗。因此，Linux选择红黑树这种近似平衡树来代替之前的AVL树（绝对平衡树）也是出于这方面的考虑。





## 异常/中断处理

此处的异常是指处理器在执行程序时产生的错误或者问题，比如除零、段溢出、页错误、无效指令、调试错误等。有的异常经过处理后，程序仍可继续执行，有的则不能继续执行，必须根据错误类型和程序逻辑进行相应的处理。而中断处理是指处理器接收到硬件设备发来的中断请求信号并作出相应处理操作。这部分内容与外围硬件设备关系非常密切，它的处理效率会影响操作系统整体的执行速度。通常，中断处理会被分为中断上半部和中断下半部。中断上半部要求快速响应中断，在取得必要的数据和信息后尽早开启中断，以使处理器能够再次接收中断请求信号。中断下半部被用来执行剩余中断内容，像数据解析、驱动程序状态调整等更耗时的内容均在这里完成。为了让更紧迫的进程优先执行，中断下半部还可将处理内容安放在一个进程中，以让更高优先级的进程得到快速执行。



## 进程管理

- 进程是程序的运行状态，所以它会比程序拥有更多管理层面的信息和数据。

- 进程调度策略：

  现代Linux内核的发展从早期的O(1)调度策略，到楼梯调度策略，再到现在的CFS完全公平调度策略，随着调度策略逐步升级，进程的执行效率也越来越高。

- 进程间通信：

  如SIGNAL信号、管道、共享内存、信号量等，这些通信机制各有特点，互相弥补不足。



## 设备驱动

为了给开发和使用设备驱动程序带来方便，不管是Linux操作系统还是Windows操作系统，它们都为驱动程序提供了一套或几套成熟的驱动框架供程序员使用。

同时，为了便于驱动程序的调试、提高即插即用设备的灵活性及缩减内核体积，操作系统逐渐把驱动程序从内核中移出，仅当使用驱动时再将其动态挂载到内核空间，从而做到驱动程序即插即用。这样一来大大缩小内核体积，加快系统启动速度。



## 文件系统

文件系统用于把机械硬盘的部分或全部扇区组织成一个便于管理的结构化单元。此处的扇区也可以是内存块，这样便组成了一个RAMDisk（内存式硬盘）。这样一个内存式硬盘单单在文件读写速度上就比普通机械硬盘高出一个数量级，其显而易见的缺点是掉电后数据全部丢失。不过与它的优点相比，这个缺点是完全可以忍受的，比如Linux内核的sys文件系统便是在RAMDisk中创建的。

文件系统的种类也是纷繁复杂的，像上面提到的sys文件系统，还有大家耳熟能详的FAT类文件系统，以及Linux的EXT类文件系统，它们对扇区的组织形式虽各具特色，却都是为了给原生操作系统提供方便、快捷的使用体验而设计的。



## 系统调用API库

系统调用API库接口有很多规范标准，比如Linux兼容的POSIX规范标准。对于不同的接口标准来说，其定义和封装的函数实现是不一样的。不管怎么说，系统调用API库最终都是为了给应用程序提供简单、快捷、便于使用的接口。





# 本书操作系统简介

本操作系统分为引导启动、内核层与应用层三部分：

- 引导启动：

  引导启动程序将使用NASM汇编语言编写，实现U盘引导启动、文件系统识别、系统内核加载、内存容量检测、显示模式的检测与设置、处理器运行模式切换、页表配置等功能，进而完成系统内核运行前的准备工作。此环节涉及的关键技术点有BIOS中断调用、VBE功能获得和设置、FAT12/32文件系统结构解析、E820内存地址分布、U盘与磁盘的区别、处理器体系结构探索等。

- 内核层：

  内核层部分是操作系统的重头戏。正如前文所述，本系统将参考Linux内核来编写一个功能相对健全的内核雏形，其中会涉及编译技术和链接技术来将程序划分出不同的代码空间。而且，系统内核还将配有内存管理模块、中断/异常处理模块、进程管理模块、多核通信模块、文件系统模块、外部设备驱动等一系列功能模块，成为一个可以正常工作且功能相对完整的系统内核。同时，本系统还将遵循POSIX规范标准，为应用层提供通用的编程接口（系统调用API）。

- 应用层：

  应用层部分将实现Shell命令解析器和一些基础命令。既然内核层已经实现了系统调用API，那么这些应用程序便可在此基础上予以实现。



# 环境搭建

## 开发过程中涉及的一些命令

- 编译器和编译工具：
  - gcc:GUN C语言编译器，支持C99标准并拥有独特的扩展。
  - as:GAS汇编语言编译器，用于编译AT&T格式的汇编语言。
  - ld：链接器，用于将编译文件链接成可执行文件。
  - nasm:NASM汇编语言编译器，用于编译Intel格式的汇编语言。
  - make：编译工具，根据编译脚本文件记录的内容编译程序。
- 系统工具与命令：
  - dd：复制指定大小的数据块，并在复制过程中转换数据格式。
  - mount：挂载命令，用于将U盘、光驱、软盘等存储设备挂载到指定路径上。
  - umount：卸载命令，与mount命令功能相反。
  - cp：复制命令，复制指定文件或目录。
  - sync：数据同步命令，将已缓存的数据回写到存储设备上。
  - rm：删除命令，删除指定文件或目录。
  - objdump：反汇编命令，负责将可执行文件反编译成汇编语言。
  - objcopy：文件提取命令，将源文件中的内容提取出来，再转存到目标文件中。



## bochs虚拟机

> 安装：
>
> [虚拟机Ubuntu20.04安装Bochs2.7过程记录 - 极客子羽 - 博客园 (cnblogs.com)](https://www.cnblogs.com/kendoziyu/p/16497178.html)
>
> [(30条消息) Ubuntu下Bochs安装与初步使用_清醒醒醒的博客-CSDN博客_bochs ubuntu](https://blog.csdn.net/qq_43627381/article/details/113358661)
>
> ```sh
> ./configure --enable-debugger
> ```
>
> 





bochs相关的调试命令：

![img](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0.assets/epub_26211970_8.jpeg)

注：

- n代表显示单元个数；
- u代表显示单元大小[b:Byte、h:Word、w:DWord、g:QWrod（四字节）]; 
- f代表显示格式（x：十六进制、d：十进制、t：二进制、c：字符）。





# 汇编

汇编语言的书写格式大体分为两种，一种是AT&T汇编语言格式，另一种是Intel汇编语言格式。这两种书写格式并不会影响汇编指令的功能，而且它们都有相应的编译器支持。

Intel汇编语言格式书写简洁，使用起来会比较舒服，支持它的编译器有MASM编译器、NASM编译器和YASM编译器。而AT&T汇编语言格式相对来说会复杂一些，支持它的编译器是GNU的GAS编译器。



对本书操作系统而言，BootLoader部分将采用Intel格式的汇编语言编写，使用NASM编译器进行编译；操作系统的内核与应用程序将采用AT&T格式的汇编语言编写，使用GNU的GAS编译器进行编译。同时使用这两种汇编语言书写格式是有原因的，可以概括为以下两点。❏ 由于BootLoader全部使用汇编语言编写，代码量大，如果采用Intel格式的汇编语言，可以保证既书写简单又便于阅读。❏ 内核和应用程序只有一小部分关键代码必须使用汇编语言编写，绝大部分代码会使用GNU C语言编写，那么为GNU C语言搭配上AT&T格式的GNU汇编语言，可使两者更加自然流畅地相互调用，进而提高两者的互相兼容性。



## AT&T汇编语言格式与Intel汇编语言格式

AT&T汇编语言格式与Intel汇编语言格式在指令的功能上并无太大区别，但在书写格式、赋值方向、前缀等方面却各有各的特点。

![img](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0.assets/epub_26211970_9.jpeg)





## NASM编译器

### 符号[ ]

- 如果直接引用变量名或标识符，则被编译器认为正在引用该变量的地址。
- 如果希望访问变量里的数据，必须使用符号[]。



### 符号$

符号$在NASM编译器中代表当前行被编译后的地址。



例如如下代码：

```nasm
jmp $
```

其功能就是一个死循环。

将它翻译成十六进制机器码是E9 FD FF。其中，机器码E9的意思是跳转，而机器码FD FF用于确定跳转的目标地址，由于==x86处理器是以小端模式==保存数据的，所以机器码转换为地址偏移值是0xfffd，即十进制数-3。从机器码E9可知，这个JMP指令完成的动作是相对跳转，跳转的目标地址是在当前指令地址减3处，这条指令的长度为3个字节，所以处理器又回到这条指令处重新执行。符号$在上述过程中指的是机器码E9之前的位置。



### 符号$$

代表一个Section（节）起始处被编译后的地址，也就是这个节的起始地址。

Section既可以是数据段，也可以是代码段。不能把Section比喻成函数，这是不恰当的。



>`$-$$`，它表示本行程序距离Section起始处的偏移。





## 使用汇编调用C函数

汇编语言调用C语言的过程都会涉及函数的调用约定、参数的传递方式、函数的调用方式等技术细节，下面就来逐一讲解这些知识点。

> 详见2.2节



### 函数的调用方式

通过汇编指令JMP、CALL、RET及其变种指令就可实现。





例如，如下C代码：

```C
int test()
{
    int i = 0;
    i = 1 + 2;
    return i;
}
int main()
{
    test();
    return 0;
}
```

反汇编这段代码编译出的程序，让我们从汇编语言的角度去看看函数test的调用过程。

使用objdump命令可以把目标程序反编译成汇编语言，该命令提供了诸多参数，通过这些参数可以从目标程序中反编译出各类想要的数据信息。读者可以参考以下命令对test程序进行反汇编：

```sh
objdump -d test
```

过滤掉多余的代码后，以下是test函数和main函数的反汇编代码片段：

```asm
0000000000400474<test>:
400474:     55                             	push    %rbp
400475:     48 89 e5                     	mov     %rsp, %rbp
400478:     c7 45 fc 00 00 00 00      		movl    $0x0, -0x4(%rbp)
40047f:     c7 45 fc 03 00 00 00      		movl    $0x3, -0x4(%rbp)
400486:     8b 45 fc                    	mov     -0x4(%rbp), %eax
400489:     c9                             	leaveq
40048a:     c3                             	retq

000000000040048b<main>:
40048b:     55                             	push    %rbp
40048c:     48 89 e5                     	mov     %rsp, %rbp
40048f:     b8 00 00 00 00              	mov     $0x0, %eax
400494:     e8 db ff ff ff              	callq   400474
400499:     b8 00 00 00 00              	mov     $0x0, %eax
40049e:     c9                             	leaveq
40049f:     c3                             	retq
```

这段代码中的000000000040048b\<main> ：是程序的主函数main，函数名前面的十六进制数000000000040048b是函数的起始地址，每个数字占4位宽度共16个数字，这也间接说明该程序运行在16×4 = 64位地址宽度下。

AT&T汇编语法格式，在引用寄存器时必须在前面添加的符号前缀。还有一些汇编指令加入了后缀字母l和q，字母l表示操作数的位宽是32位（一个双字），字母q表示操作数的位宽是64位（一个四字）。



### 函数的调用规定

函数的调用约定==描述了执行函数时返回地址和参数的出入栈规律==。

不同公司开发的C语言编译器都有各自的函数调用约定，而且这些调用约定的差异性很大。



- stdcall调用约定：

  - 在调用函数时，参数将按照从右向左的顺序依次压入栈中，例如下面的function函数，其参数入栈顺序依次是second、first：

    ```C++
    int function(int first, int second)

  - 函数的栈平衡操作（参数出栈操作）是由被调用函数完成的。通过代码retn x可在函数返回时从栈中弹出x字节的数据。当CPU执行RET指令时，处理器会自动将栈指针寄存器ESP向上移动x个字节，来模拟栈的弹出操作。例如上面的function函数，当function函数返回时，它会执行该指令把参数second和first从栈中弹出来，再到返回地址处继续执行。

  - 在函数的编译过程中，编译器会在函数名前用下划线修饰，其后用符号@修饰，并加上入栈的字节数，因此函数function最终会被编译为_function@8。

- cdecl调用约定

- fastcall调用约定



### 参数传递方式

在知晓函数的调用约定后不难发现，参数的传递方式无外乎两种，一种是寄存器传递方式，另一种是内存传递方式。



- 寄存器传递参数：

  此种传递方式的优点是执行速度快，只有少数调用约定默认使用寄存器来传递参数的，而绝大部分编译器需要特殊指定传递参数的寄存器。

  >在基于x86体系结构的Linux内核中，系统调用API一般会使用寄存器传递方式。因为，应用层空间与内核层空间是相隔离的，若想从应用层把参数传递至内核层，最便捷的方法是通过寄存器来携带参数，否则就只能大费周折地在两个层之间搬运数据。

- 内存传递参数：

  在大多数情况下，函数参数都是以压栈方式传递到目标函数中的。

  >同在x86体系结构的Linux内核中，中断处理过程和异常处理过程都会使用内存传参方式。（从Linux 2.6开始逐渐改为寄存器传递方式。）因为从中断/异常产生到调用相应的处理，这期间的过渡代码全部由汇编语言编写。在汇编语言跳转至C语言函数的过程中，C语言函数使用栈来传递参数，为了保证两种开发语言的无缝衔接，在汇编代码中必须把参数压入栈中，然后再跳转到C语言实现的中断处理函数中执行。

以上内容均是基于x86体系结构的参数传递方式。而在x64体系结构下，大多数编译器选择寄存器传参方式。



# C

## GNU C内嵌汇编语言

在很多操作系统开发场景中，C语言依然无法完全代替汇编语言。例如，操作某些特殊的CPU寄存器、操作主板上的某些IO端口或者对性能要求极为苛刻的场景等，此时我们必须***在C语言内嵌入汇编语言***来满足上述要求。



GNU C语言提供了关键字asm来声明代码是内嵌的汇编语句，如下面这行代码：

```C
#define nop()     __asm__ __volatile__ ("nop     \n\t")
```

这条内嵌汇编语句的作用可从函数名中知晓，它正是nop函数（空操作函数）的实现。



C语言使用关键字`__asm__`和`__volatile__`对汇编语句加以修饰，这两个关键字在C语言内嵌汇编语句时经常使用。

- `__asm__`关键字：

  用于声明这行代码是一个内嵌汇编表达式，它是关键字asm的宏定义（`#define __asm__ asm`）。故此，它是内嵌汇编语言必不可少的关键字，任何内嵌的汇编表达式都以此关键字作为开头；如果希望编写符合ANSI C标准的代码（即与ANSI C标准相兼容），那么建议使用关键字`__asm__`。

- `__volatile__`关键字：

  其作用是告诉编译器此行代码不能被编译器优化，编译时保持代码原状。由此看来，它也是内嵌汇编语言不可或缺的关键字，否则经过编译器优化后，汇编语句很可能被修改以至于无法达到预期的执行效果。如果期望编写处符合ANSI C标准的程序（即与ANSI C标准兼容），那么建议使用关键字__volatile__。



GNU C语言的内嵌汇编表达式并非像nop函数一般简单，它有着极为复杂的书写格式。接下来将书写格式分为内嵌汇编表达式、操作约束和修饰符、序号占位符三部分进行讲解。

### 内嵌汇编表达式

GNU C语言的内嵌汇编表达式由4部分构成，它们之间使用“:”号分隔，其完整格式为：

`指令部分：输出部分：输入部分：损坏部分`

如果将内嵌汇编表达式当作函数，指令部分是函数中的代码，输入部分用于向函数传入参数，而输出部分则可以理解为函数的返回值。

- 指令部分是汇编代码本身，其书写格式与AT&T汇编语言程序的书写格式基本相同，但也存在些许不同之处。指令部分是内嵌汇编表达式的必填项，而其他部分视具体情况而定，如果不需要的话则可以直接忽略。在最简单的情况下，指令部分与常规汇编语句基本相同，如nop函数。

  指令部分的编写规则要求是：当指令表达式中存在多条汇编代码时，可全部书写在一对双引号中；亦可将汇编代码放在多对双引号中。如果将所有指令编写在同一双引号中，那么相邻两条指令间必须使用分号（;）或换行符（\n）分隔。如果使用换行符，通常在其后还会紧跟一个制表符（\t）。当汇编代码引用寄存器时，必须在寄存器名前再添加一个 % 符，以表示对寄存器的引用，例如代码"movl $0x10, %%eax"。

- 输出部分紧接在指令部分之后，这部分记录着指令部分的输出信息，其格式为：“输出操作约束”（输出表达式）, “输出操作约束”（输出表达式）, ……。格式中的输出操作约束和输出表达式成对出现，整个输出部分可包含多条输出信息，每条信息之间必须使用逗号“, ”分隔开。
  - 括号内的输出表达式部分主要负责保存指令部分的执行结果。通常情况下，输出表达式是一个变量。
  - 双引号内的部分，被称为“输出操作约束”，也可简称为“输出约束”。输出约束部分必须使用等号“=”或加号“+”进行修饰。这两个符号的区别是，等号“=”意味着输出表达式是一个纯粹的输出操作，加号“+”意味着输出表达式既用于输出操作，又用于输入操作。不论是等号“=”还是加号“+”，它们只能用在输出部分，不能出现在输入部分，而且是可读写的。关于输出约束的更多内容，将在“操作约束和修饰符”中进行补充。
- 输入部分记录着指令部分的输入信息，其格式为：“输入操作约束”（输入表达式）,“输入操作约束”（输入表达式）, ……。格式中的输入操作约束与输入表达式同样要求成对出现，整个输入部分亦可包含多条输入信息，并用逗号“, ”分隔开。在输入操作约束中不允许使用等号“=”和加号“+”，因此输入部分是只读的。

- 损坏部分描述了在指令部分执行的过程中，将被修改的寄存器、内存空间或标志寄存器，并且这些修改部分并未在输出部分和输入部分出现过，格式为：“损坏描述”, “损坏描述”, ……。如果需要声明多个寄存器，则必须使用逗号“, ”将它们分隔开，这点与输入/输出部分一致。

  - 寄存器修改通知。这种情况一般发生在寄存器出现于指令部分，又不是输入/输出操作表达式指定的寄存器，更不是编译器为r或g约束选择的寄存器。如果该寄存器被指令部分所修改，那么就应该在损坏部分加以描述，比如下面这行代码：

    ```C
    __asm__ __volatile__ ("movl %0, %%ecx"::"a"(__tmp):"cx");
    ```

    这段汇编表达式的指令部分修改了寄存器ECX的值，却未被任何输入/输出部分所记录，那么必须在损坏部分加以描述，一旦编译器发现后续代码还要使用它，便会在内嵌汇编语句的过程中做好数据保存与恢复工作。如果未在损坏部分描述，则很可能会影响后续程序的执行结果。

    注意，已在损坏部分声明的寄存器，不能作为输入/输出操作表达式的寄存器约束，也不会被指派为q 、 r 、 g约束的寄存器。如果在输入/输出操作表达式中已明确选定寄存器，或者使用q 、 r 、 g约束让编译器指派寄存器时，编译器对这些寄存器的状态非常清楚，它知道哪些寄存器将会被修改。除此之外，编译器对指令部分修改的寄存器却一无所知。

  - 内存修改通知。除了寄存器的内容会被篡改外，内存中的数据同样会被修改。如果一个内嵌汇编语句的指令部分修改了内存数据，或者在内嵌汇编表达式出现的地方，内存数据可能发生改变，并且被修改的内存未使用m约束。此时，应该在损坏部分使用字符串memory，向编译器声明内存会发生改变。如果损坏部分已经使用memory对内存加以约束，那么编译器会保证在执行汇编表达式之后，重新向寄存器装载已引用过的内存空间，而非使用寄存器中的副本，以防止内存与副本中的数据不一致。
  - 标志寄存器修改通知。当内嵌汇编表达式中包含影响标志寄存器R|EFLAGS的指令时，必须在损坏部分使用cc来向编译器声明这一点。



### 操作约束和修饰符

每个输入/输出表达式都必须指定自身的操作约束。操作约束的类型可以细分为寄存器约束、内存约束和立即数约束。在输出表达式中，还有限定寄存器操作的修饰符。



### 序号占位符



## GUN C语言对标准C的扩展

### 柔性数组成员（或称零长数组、变长数组）

GNU C语言允许使用长度为0的数组来增强结构体的灵活性，其在动态创建结构体时有着非常明显的优势，例如下面这几行代码：

```C++
struct s {int n; long d[0]; };
int m = 数值；
struct s ＊p = malloc(sizeof (struct s) + sizeof (long [m]));
```

struct s结构体中的数组成员变量d在作用上与指针极为相似，但是在为指针p开辟存储空间时却仅需执行一次malloc函数。由此可见，柔性数组成员不仅能够减少内存空间的分配次数提高程序执行效率，还能有效保持结构体空间的连续性。



### case关键字支持范围匹配

GNU C语言允许case关键字匹配一个数值范围，由此可以取代多级的if条件检测语句。以下这段代码的执行条件是待匹配字符为小写字母：

```C++
case 'a'...'z':   /*from 'a' to 'z'*/
    break;
```



### typeof关键字获取变量类型

借助关键字typeof(x)可以取得变量x的数据类型，在编写宏定义时，关键字typeof经常会派上用场。



### 可变参数宏

在GNU C语言中宏函数允许使用可变参数类型，例如：

```C++
#define pr_debug(fmt, arg...) \
        printk(fmt, ##arg)
```



在这段代码中，当可变参数arg被忽略或为空时，printk函数中的##操作将迫使预处理器去掉它前面的那个逗号。如果在调用宏函数时，确实提供了若干个可变参数，那么GNU C会把这些可变参数放到逗号后面，使其能够正常工作。



### 当前函数名

GNU C语言为当前函数的名字准备了两个标识符，它们分别是`__PRETTY__FUNCTION__`和`__FUNCTION__`，其中`__FUNCTION__`标识符保存着函数在源码中的名字，`__PRETTY__FUNCTION__`标识符则保存着带有语言特色的名字。在C函数中，这两个标识符代表的函数名字相同，参考代码如下所示：

```C++
void func_example()
{
    printf("the function name is %s", __FUNCTION__);
}
```





### 特殊属性修饰

在声明处加入关键字`__attribute__((ATTRIBUTE))`即可指定特殊属性，

目前GNU C语言支持的属性说明有noreturn、noinline、always_inline、pure、const、nothrow、format、format_arg、no_instrument_function、section、constructor、destructor、used、unused、deprecated、weak、malloc、aliaswarn_unused_result nonnull等。

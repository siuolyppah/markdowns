# 内联命名空间的定义和使用（C++11）

内联命名空间能够把空间内函数和类型导出到父命名空间中，这样即使不指定子命名空间，也可以使用其空间内的函数和类型。



```C++
namespace Parent {
	namespace Child1 { 
		void foo() { std::cout << "Child1::foo()" << std::endl; } 
	}  

	inline namespace Child2 {
		void foo() { std::cout << "Child2::foo()" << std::endl; } 
	} 
}

int main() { 
	Parent::Child1::foo(); 
	Parent::foo(); 
}
```



- 这个新特性的用途是什么呢？

  - 如果删除内联命名空间，将foo函数直接纳入Parent命名空间也能达到同样的效果。

  - 实际上，该特性可以==帮助库作者无缝升级库代码==，让客户不用修改任何代码也能够自由选择新老库代码。

  ```C++
  // 升级前
  namespace Parent{
      void foo() { std::cout << "foo v1.0" << std::endl; } 
  }
  
  // 升级后
  namespace Parent {
  	namespace V1 { 
  		void foo() { std::cout << "foo v1.0" << std::endl; } 
  	}  
  	
  	inline namespace V2 { 
  		void foo() { std::cout << "foo v2.0" << std::endl; } 
  	} 
  }
  
  int main() { 
  	Parent::foo(); 
  }
  ```

  虽然foo函数从V1升级到了V2，但是客户的代码并不需要任何修改。如果用户还想使用V1版本的函数，则只需要统一添加函数版本的命名空间，比如Parent::V1::foo().



# 嵌套命名空间的简化语法（C++17&C++20）

```C++
namespace A::B::C {  
    int foo() { return 5; }
}
```

以上代码等同于：

```C++
namespace A { 
    namespace B {
        namespace C {
            int foo() { return 5; }      
        } 
    }
}
```



在==C++17标准中没有办法简洁地定义<u>内联命名空间</u>==，这个问题直到C++20标准才得以解决。

在C++20中，我们可以这样定义内联命名空间：

```C++
namespace A::B::inline C {
    int foo() { return 5; }
}
// 或者
namespace A::inline B::C { 
    int foo() { return 5; }
}
```


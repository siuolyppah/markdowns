# 回顾变量初始化

传统初始化方式：

- 使用`=`
- 使用`()`

```C++
struct C {
  C(int a) {}
};

int main()
{
  int x = 5;
  int x1(8);
  C x2 = 4;
  C x3(4);
}
```

一般来说，我们称==使用括号初始化的方式叫作直接初始化，而使用等号初始化的方式叫作拷贝初始化（复制初始化）==。



>- 直接初始化：
>  1. 使用`()`的方式，`A a(10);`
>  2. `new`运算符，`new A(10);`
>  3. 类构造函数中的初始化列表
>- 拷贝初始化：
>  1. 使用`=`的方式，`A a = A(10;`
>  2. 函数传参，`foo(A(1));`
>  3. return返回，`A a = foo();`



# 使用列表初始化(C++11)

和传统变量初始化的规则一样，它也区分为直接初始化和拷贝初始化。

```C++
#include <iostream>

struct C {
  C(std::string a, int b) {}
  C(int a) {}
};

void foo(C) {}
C bar()
{
  return {"world", 5};
}

int main()
{
  int x = {5};         // 拷贝初始化
  int x1{8};           // 直接初始化
  C x2 = {4};          // 拷贝初始化
  C x3{2};             // 直接初始化
  foo({8});            // 拷贝初始化
  foo({"hello", 8});   // 拷贝初始化
  C x4 = bar();        // 拷贝初始化
  C *x5 = new C{ "hi", 42 };  // 直接初始化
}
```

> 声明为explicit可禁用隐式构造函数。



## 容器开始支持初始化列表

```C++
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>

int main()
{
  int x[] = { 1,2,3,4,5 };
  int x1[]{ 1,2,3,4,5 };
  std::vector<int> x2{ 1,2,3,4,5 };
  std::vector<int> x3 = { 1,2,3,4,5 };
  std::list<int> x4{ 1,2,3,4,5 };
  std::list<int> x5 = { 1,2,3,4,5 };
  std::set<int> x6{ 1,2,3,4,5 };
  std::set<int> x7 = { 1,2,3,4,5 };
  std::map<std::string, int> x8{ {"bear",4}, {"cassowary",2}, {"tiger",7} };
  std::map<std::string, int> x9 = { {"bear",4}, {"cassowary",2}, {"tiger",7} };
}
```

> 一值得注意的地方是对x8和x9的初始化。
>
> 内层{"bear",4}、{"cassowary",2}和{"tiger",7}都隐式调用了std::pair的构造函数pair(const T1& x, const T2& y)，而外层的{…}隐式调用的则是std::map的构造函数map(std::initializer_list<value_type>init, const Allocator&)。



# 容器与std::initializer_list详解

标准容器之所以能够支持列表初始化，离不开编译器支持的同时，它们自己也必须满足一个条件：支持std::initializer_list为形参的构造函数。

==std::initializer_list简单地说就是一个支持begin、end以及size成员函数的类模板==。

> 编译器负责将列表里的元素（大括号包含的内容）构造为一个std::initializer_list的对象，然后寻找标准容器中支持std:: initializer_list为形参的构造函数并调用它。



例如：

```C++
#include <iostream>

struct C
{
    C(std::initializer_list<std::string> strlist)
    {
        for (const std::string *item = strlist.begin(); item != strlist.end(); ++item)
        {
            std::cout << *item << " ";
        }

        std::cout << std::endl;
    }
};

int main()
{
    C c{"hello","c++","world"};

    return 0;
}
```

>以上代码的逻辑：
>
>1. 编译使用{"hello","c++","world"}，构造一个std::initializer_list对象
>2. 将改对象传入构造函数

>一般情况下，使用初始化列表构造对象的流程：
>
>1. 利用初始化列表中的参数，直接构造目标对象。
>
>> 即编译器不会生成中间过程的initializer_list对象



# 使用初始化列表的注意事项

## 隐式缩窄转换问题

在C++中哪些属于隐式缩窄转换的4条规则：

1. 从浮点类型转换整数类型；
2. 从long double转换到double或float，或从double转换到float，除非转换源是常量表达式以及转换后的实际值在目标可以表示的值范围内；
3. 从整数类型或非强枚举类型转换到浮点类型，除非转换源是常量表达式，转换后的实际值适合目标类型并且能够将生成目标类型的目标值转换回原始类型的原始值。
4. 从整数类型或非强枚举类型转换到不能代表所有原始类型值的整数类型，除非源是一个常量表达式，其值在转换之后能够适合目标类型。

```C++
int x = 999;
const int y = 999;
const int z = 99;
const double cdb = 99.9;
double db = 99.9;
char c1 = x;  // 编译成功，传统变量初始化支持隐式缩窄转换
char c2{ x }; // 编译失败，可能是隐式缩窄转换，对应规则4
char c3{ y }; // 编译失败，确定是隐式缩窄转换，999超出char能够适应的范围，对应规则4
char c4{ z }; // 编译成功，99在char能够适应的范围内，对应规则4
unsigned char uc1 = { 5 };  // 编译成功，5在unsigned char能够适应的范围内，
                            // 对应规则4
unsigned char uc2 = { -1 }; // 编译失败，unsigned char不能够适应负数，对应规则4
unsigned int ui1 = { -1 };  //编译失败，unsigned int不能够适应负数，对应规则4
signed int si1 = { (unsigned int)-1 }; //编译失败，signed int不能够适应-1所对应的
                                   //unsigned int，通常是4294967295，对应规则4
int ii = { 2.0 };  // 编译失败，int不能适应浮点范围，对应规则1
float f1{ x };     // 编译失败，float可能无法适应整数或者互相转换，对应规则3
float f2{ 7 };     // 编译成功，7能够适应float，且float也能转换回整数7，对应规则3
float f3{ cdb };   // 编译成功，99.9能适应float，对应规则2
float f4{ db };    // 编译失败，可能是隐式缩窄转无法表达double，对应规则2
```



## 列表初始化的优先级问题

>回顾：
>
>==列表初始化既可以支持普通的构造函数，也能够支持以std::initializer_list为形参的构造函数==。

编译器优先选择std::initializer_ list。



# 指定初始化（C++20）

为了提高数据成员初始化的可读性和灵活性，==该特性允许指定初始化数据成员的名称==。

```C++
struct Point {
  int x;
  int y;
};

Point p{ .x = 4, .y = 2 };
```



允许进行指定初始化的对象，有如下限制：

1. 它要求对象必须是一个==聚合类型==。例如下面的结构体就无法使用指定初始化：

   ```C++
   struct Point3D {
     Point3D() {}
     int x;
     int y;
     int z;
   };
   
   Point3D p{ .z = 3 };    // 编译失败，Point3D不是一个聚合类型

2. 指定的数据成员必须是非静态数据成员。这一点很好理解，静态数据成员不属于某个对象。

3. 每个非静态数据成员最多只能初始化一次：

   ```C++
   Point p{ .y = 4, .y = 2 };  // 编译失败，y不能初始化多次

4. 非静态数据成员的初始化必须按照声明的顺序进行。

   ```C++
   Point p{ .y = 4, .x = 2 };  // C++编译失败，C编译没问题

5. 针对联合体中的数据成员只能初始化一个，不能同时指定：

   ```C++
   union u {
     int a; 
     const char* b; 
   };
   
   u f = { .a = 1 };        // 编译成功
   u g = { .b = "asdf" };   // 编译成功
   u h = { .a = 1, .b = "asdf" };    // 编译失败，同时指定初始化联合体中的多个数据成员

6. 不能嵌套指定初始化数据成员。虽然这一点在C语言中也是允许的。

   ```C++
   struct Line {
     Point a;
     Point b;
   };
   
   Line l{ .a.y = 5 }; // 编译失败, .a.y = 5访问了嵌套成员，不符合C++标准
   ```

   >当然，如果确实想嵌套指定初始化，我们可以换一种形式来达到目的：
   >
   >```C++
   >Line l{ .a {.y = 5} };

7. 一旦使用指定初始化，就不能混用其他方法对数据成员初始化了，而这一点在C语言中是允许的：

   ```C++
   Point p{ .x = 2, 3 };    // 编译失败，混用数据成员的初始化

8. 指定初始化对数组的处理，无法类似C语言一样：因为语法和lambda表达式冲突。

   ```C++
   int arr[3] = { [1] = 5 };    // 编译失败
   ```

   


# 聚合类的列表初始化

> C++ Primer(第五版) P266




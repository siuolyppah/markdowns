# long long类型（C++11）

- long long等价于 long long int，同理 unsigned long long 等价于 unsigned long long int.

- 初始化long long型变量：

  ```C++
  long long x = 65536LL;
  long long x = 65536; // ok
  ```

  ==字面值后缀(`LL`/`ULL`)，在特定场合下不能省略==：

  ```c++
  long long x1 = 65536 << 16;      // 计算得到的x1值为0
  std::cout << "x1 = " << x1 << std::endl;
  
  long long x2 = 65536LL << 16;    // 计算得到的x2值为4294967296（0x100000000）
  std::cout << "x2 = " << x2 << std::endl;
  ```

  

- long long类型用于==用作位域和枚举==。

- 取值范围：

  - 宏：

    ```C++
    #define LLONG_MAX 9223372036854775807LL         // long long的最大值
    #define LLONG_MIN (-9223372036854775807LL - 1)  // long long的最小值
    #define ULLONG_MAX 0xffffffffffffffffULL        // unsigned long long的最大值
    ```

  - 特化的`numeric_limits`类模板：

    ```C++
    #include <iostream>
    #include <limits>
    
    using namespace std;
    
    int main()
    {
        cout << numeric_limits<long long>::min() << endl;
        cout << numeric_limits<long long>::max() << endl;
        cout << numeric_limits<unsigned long long>::max() << endl;
    
        return 0;
    }
    ```



# char16_t和char32_t类型（C++11）

[现代C++语言核心特性解析-谢丙堃-微信读书 (qq.com)](https://weread.qq.com/web/reader/22d32dd0726fa07122d86dbk6f4322302126f4922f45dec)

>分别用来对应Unicode字符集的UTF-16和UTF-32两种编码方法



## 字符集和编码方法

- 字符集是指系统支持的所有抽象字符的集合，通常一个字符集的字符是稳定的。

  >除了Unicode字符集，我们常见的字符集还包括ASCII字符集、GB2312字符集、BIG5字符集等，它们都有各自的编码方法。

- 编码方法是利用数字和字符集建立对应关系的一套方法，这个方法可以有很多种，比如Unicode字符集就有UTF-8、UTF-16和UTF-32这3种编码方法。



==字符集需要和编码方式对应，如果这个对应关系发生了错乱，就会出现乱码==。



## Unicode字符集及其编码方法

- Unicode字符集的最大个数==0x10FFFF==（即不超过21位）（ISO 10646）。



- UTF-32编码：

  用一个32位的内存空间（也就是4字节）存储一个字符编码。

- UTF-16编码：

  - 一个代码单元占用16位。

    > 为了表示一个Unicode码点，通常只需要一个UTF-16代码单元，不常用的需要用两个代码单元表示。

  - 从0x0000～0xD7FF以及0xE000～0xFFFF直接映射到Unicode字符集，而剩下的0xD800～0xDFFF则用于映射0x10000～0x10FFFF的Unicode字符集，映射方法为：字符编码减去0x10000后剩下的20比特位分为高位和低位，高10位的映射范围为0xD800～0xDBFF，低10位的映射范围为0xDC00～0xDFFF。例如0x10437，减去0x10000后的高低位分别为0x1和0x37，分别加上0xD800和0xDC00的结果是0xD801和0xDC37。

  > [UTF-16编码详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/106379925)
  >
  > [(30条消息) 字符集与字符编码（Unicode、UTF-8、UTF-16、UTF-32的编码逻辑）_Tango小黄的博客-CSDN博客](https://blog.csdn.net/luwulu1056/article/details/123336506)

  ![preview](%E6%96%B0%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B.assets/v2-aee5ae604328ab912b285d03b6c62273_r.jpg)

- UTF-8编码：

  - 一个代码单元占用8位。

    > 常用的Unicode码点，使用1\~2字节表示，其余字符采用3\~4字节表示。

  - 对应方式为：
  
    ![img](%E6%96%B0%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B.assets/epub_40870001_6.jpeg)



## 新字符char16_t和char32_t

对于UTF-8编码方法而言，普通类型似乎是无法满足需求的，==毕竟普通类型无法表达变长的内存空间==。

> char占用一个字节。



用于声明3种编码字符和字符串的字面量：

- UTF-8的前缀`u8`
- UTF-16的前缀`u`
- UTF-32的前缀`U`

```C++
char utf8c = u8'a';
// char utf8c = u8'好';
char16_t utf16c = u'好';
char32_t utf32c = u'好';

char utf8[] = u8"你好世界";
char16_t utf16[] = u"你好世界";
char32_t utf32[] = U"你好世界";
```

>注意点：
>
>- 在C++11标准中，u8只能作为字符串字面值的前缀，而不能作为字符的前缀。在C++17标准中才得以解决。
>
>- 字符`'好'`，需要3个字节，显然变量utf8c只能存储1字节，所以会编译失败。



## wchar_t存在的问题

- 在C++98标准中，提供了wchar_t字符类型，以及前缀L。
- 在定义wchat_t时，并没有规定其占用内存的大小，在实现上：
  - Windows是16位长度；
  - Linux和macOS是32位长度。

导致代码无法在不同平台上保持相同行为。



## 字符串的连接

- 如果两个字符串字面量具有相同的前缀，则生成的连接字符串字面量也具有该前缀；

- 如果其中一个字符串字面量没有前缀，则将其视为与另一个字符串字面量具有相同前缀的字符串字面量；

  ![img](%E6%96%B0%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B.assets/epub_40870001_7.jpeg)

- 其他的连接行为由具体实现者定义。

> 这里的连接操作是编译时的行为，而不是一个转换。



## 库对新字符类型的支持

C11在中增加了4个字符的转换函数（`<cuchar>`），包括：

```C++
size_t mbrtoc16( char16_t* pc16, const char* s, size_t n, mbstate_t* ps );
size_t c16rtomb( char* s, char16_t c16, mbstate_t* ps );
size_t mbrtoc32( char32_t* pc32, const char* s, size_t n, mbstate_t* ps );
size_t c32rtomb( char* s, char32_t c32, mbstate_t* ps );
```

功能分别是多字节字符和UTF-16编码字符互转，以及多字节字符和UTF-32编码字符互转。



除此之外，==C++标准库的字符串也加入了对新字符类型的支持==，例如：

```C++
using u16string = basic_string;
using u32string = basic_string;
using wstring = basic_string;
```



# char8_t字符类型（C++20)

- 使用char类型来处理UTF-8字符虽然可行，但是也会带来一些困扰。
- char8_t具有和unsigned char相同的符号属性、存储大小、对齐方式以及整数转换等级。



在引入char8_t后，在C++17环境下编译成功的代码，可能在C++20下编译失败：
```C++
char str[] = u8"text";  // C++17编译成功；C++20编译失败，需要char8_t
char c = u8'c';

char8_t c8a[] = "text"; // C++20编译失败，需要char
char8_t c8 = 'c';
```



==为了匹配新的char8_t字符类型，库函数也有相应的增加==：

```C++
size_t mbrtoc8(char8_t* pc8, const char* s, size_t n, mbstate_t* ps);
size_t c8rtomb(char* s, char8_t c8, mbstate_t* ps);
using u8string = basic_string;
```


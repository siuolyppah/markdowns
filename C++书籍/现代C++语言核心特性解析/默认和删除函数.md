# 类的特殊成员函数（C++11）

对于类的某些构造函数，当其缺省时，会由编译器生成默认的。

这样的成员函数分别是：

1. 默认构造函数

   > 生成的默认构造函数什么也不做，既不会将其成员变量置零，也不会做其他的任何事情，只是为了保证程序能够正确运行而已.。

2. 析构函数

3. 复制构造函数

4. 复制赋值运算符函数

5. 移动构造函数

6. 移动赋值运算符函数



但存在如下限制：

1. 声明任何构造函数都会抑制默认构造函数的添加。
2. 一旦用自定义构造函数代替默认构造函数，类就将转变为==非平凡类型==。
3. ~~没有明确的办法彻底禁止特殊成员函数的生成（C++11之前）~~。



# 显式默认和显式删除

在声明函数的尾部添加`=default`和`=delete`，它们分别指示编译器添加特殊函数的默认版本以及删除指定的函数：

```C++
struct type
{
  type() = default;
  virtual ~type() = delete;
  type(const type &);
};
type::type(const type &) = default;
```

以上代码显式地添加了默认构造和复制构造函数，同时也删除了析构函数。

>- =default，可以添加到类内部函数声明，也可以添加到类外部。
>
>- =delete，必须添加在类内部的函数声明中。





==使用显式默认说明，能保持类的平凡类型==：

```C++
class NonTrivial
{
  int i;
public:
  NonTrivial(int n) : i(n), j(n) {}
  NonTrivial() {}
  int j;
};

class Trivial
{
  int i;
public:
  Trivial(int n) : i(n), j(n) {}
  Trivial() = default;
  int j;
};

int main()
{
  Trivial a(5);
  Trivial b;
  b = a;
  std::cout << "std::is_trivial_v<Trivial>   : " << std::is_trivial_v<Trivial> << std::endl;
  std::cout << "std::is_trivial_v<NonTrivial> : " << std::is_trivial_v<NonTrivial> << std::endl;
}
```



# 显式删除的其他用法

- 于普通函数同样有效。只不过相对于应用于成员函数，应用于普通函数的意义就不大了：

  ```C++
  void foo() = delete;
  static void bar() = delete;
  int main()
  {
    bar();        // 编译失败，函数已经被显式删除
    foo();        // 编译失败，函数已经被显式删除
  }

- 显式删除还可以用于类的new运算符和类析构函数。

  - ==显式删除特定类的new运算符可以阻止该类在堆上动态创建对象==，换句话说它可以限制类的使用者只能通过自动变量、静态变量或者全局变量的方式创建对象，例如：

    ```C++
    struct type 
    {
      void * operator new(std::size_t) = delete;
    };
    
    type global_var;
    int main()
    {
      static type static_var;
      type auto_var;
      type *var_ptr = new type;    // 编译失败，该类的new已被删除
    }
    ```

  - ==显式删除类的析构函数==在某种程度上和删除new运算符的目的正好相反，它==阻止类通过自动变量、静态变量或者全局变量的方式创建对象，但是却可以通过new运算符创建对象==。

    >原因是删除析构函数后，类无法进行析构。所以像自动变量、静态变量或者全局变量这种会隐式调用析构函数的对象就无法创建了，当然了，通过new运算符创建的对象也无法通过delete销毁。

    例如：

    ```C++
    struct type 
    {
      ~type() = delete;
    };
    type global_var;             // 编译失败，析构函数被删除无法隐式调用
    
    int main()
    {
      static type static_var;    // 编译失败，析构函数被删除无法隐式调用
      type auto_var;             // 编译失败，析构函数被删除无法隐式调用
      type *var_ptr = new type;
      delete var_ptr;            // 编译失败，析构函数被删除无法显式调用
    }

  

  

- 




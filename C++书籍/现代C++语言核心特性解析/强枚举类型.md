# 枚举类型的弊端（C++11之前）

- 虽然枚举类型存在一定的安全检查功能，一个枚举类型不允许分配到另外一种枚举类型，而且整型也无法隐式转换成枚举类型。

- 但是==枚举类型却可以隐式转换为整型==，因为C++标准文档提到“枚举类型可以采用整型提升的方法转换成整型”。

  ```C++
  enum School {
    principal,
    teacher,
    student
  };
  
  enum Company {
    chairman,
    manager,
    employee
  };
  
  int main()
  {
    School x = student;
    Company y = manager;
    bool b = student >= manager;    // 不同类型之间的比较操作
    b = x < employee;
    int y = student;                // 隐式转换为int
  }
  ```

- 枚举类型的作用域问题，==枚举类型会把其内部的枚举标识符导出到枚举被定义的作用域==。

  ```C++
  enum HighSchool {
    student,
    teacher,
    principal
  };
  
  enum University {
    student,
    professor,
    principal
  };
  ```

  HighSchool和University都有student和principal，而枚举类型又会将其枚举标识符导出到定义它们的作用域，这样就会发生重复定义，无法通过编译。解决此类问题的一个办法是使用命名空间，例如：

  ```C++
  enum HighSchool {
    student,
    teacher,
    principal
  };
  
  namespace AcademicInstitution
  {
  enum University {
    student,
    professor,
    principal
  };
  }
  ```

  这样一来，University的枚举标识符就会被导出到AcademicInstitution的作用域，和HighSchool的全局作用域区分开来。

- 无法指定枚举类型的底层类型。因此，不同的编译器对于相同枚举类型可能会有不同的底层类型，甚至有无符号也会不同。





对于前面两个问题，有一个比较好但并不完美的解决方案，代码如下：

```C++
#include 

class AuthorityType {
 enum InternalType
 {
     ITBan,
     ITGuest,
     ITMember,
     ITAdmin,
     ITSystem,
 };

 InternalType self_;

public:
 AuthorityType(InternalType self) : self_(self) {}

 bool operator < (const AuthorityType &other) const
 {
     return self_ < other.self_;
 }

 bool operator > (const AuthorityType &other) const
 {
     return self_ > other.self_;
 }

 bool operator <= (const AuthorityType &other) const
 {
     return self_ <= other.self_;
 }

 bool operator >= (const AuthorityType &other) const
 {
     return self_ >= other.self_;
 }

 bool operator == (const AuthorityType &other) const
 {
     return self_ == other.self_;
 }

 bool operator != (const AuthorityType &other) const
 {
     return self_ != other.self_;
 }

 const static AuthorityType System, Admin, Member, Guest, Ban;
};

#define DEFINE_AuthorityType(x) const AuthorityType \
 AuthorityType::x(AuthorityType::IT ## x)
DEFINE_AuthorityType(System);
DEFINE_AuthorityType(Admin);
DEFINE_AuthorityType(Member);
DEFINE_AuthorityType(Guest);
DEFINE_AuthorityType(Ban);

int main()
{
 bool b = AuthorityType::System > AuthorityType::Admin;
 std::cout << std::boolalpha << b << std::endl;
}
```

将枚举类型变量封装成类私有数据成员，保证无法被外界访问。访问枚举类型的数据成员必须通过对应的常量静态对象。另外，根据C++标准的约束，访问静态对象必须指明对象所属类型。也就是说，如果我们想访问ITSystem这个枚举标识符，就必须访问常量静态对象System，而访问System对象，就必须说明其所属类型，这使我们需要将代码写成AuthorityType:: System才能编译通过。





# 使用强枚举类型（C++11）

强枚举类型具备以下3个新特性：

1. ==枚举标识符属于强枚举类型的作用域==。
2. 枚举标识符不会隐式转换为整型。
3. 能指定强枚举类型的底层类型，底层类型默认为int类型。

使用`enum class`定义强枚举类型：

```C++
#include <iostream>

enum class HighSchool {
    student,
    teacher,
    principal
};

enum class University {
    student,
    professor,
    principal
};

int main()
{
    HighSchool x = HighSchool::student;
    University y = University::student;
    bool b = x < HighSchool::headmaster;
    std::cout << std::boolalpha << b << std::endl;
}
```

首先，在不使用命名空间的情况下，两个有着相同枚举标识符的强枚举类型可以在一个作用域内共存。这符合强枚举类型的第一个特性，其枚举标识符属于强枚举类型的作用域，无法从外部直接访问它们，所以在访问时必须加上枚举类型名，否则会编译失败，如HighSchool::student。

其次，相同枚举类型的枚举标识符可以进行比较，但是不同枚举类型就无法比较其枚举标识符了，因为它们失去了隐式转换为整型的能力，这一点符合强枚举类型的第二个特性：

```C++
HighSchool x = student;              // 编译失败，找不到student的定义
bool b = University::student < HighSchool::headmaster;// 编译失败，比较的类型不同
int y = University::student;         // 编译失败，无法隐式转换为int类型
```

> 事实上，可以通过static_cast对其进行强制类型转换，但建议不要这样做。

对于强枚举类型的第三个特性，我们可以在定义类型的时候使用:符号来指明其底层类型。利用它可以消除不同编译器带来的歧义：

```C++
enum class E : unsigned int {
    e1 = 1,
    e2 = 2,
    e3 = 0xfffffff0
};

int main()
{
    bool b = e1 < e3;
    std::cout << std::boolalpha << b << std::endl;
}
```





特别的，C++11也允许对普通的枚举类型，指定底层类型：
```C++
enum E : unsigned int {
    e1 = 1,
    e2 = 2,
    e3 = 0xfffffff0
};

int main()
{
    bool b = e1 < e3;
    std::cout << std::boolalpha << b << std::endl;
}
```





# 列表初始化有底层类型的枚举对象（C++17）

> review：
>
> - int -> 枚举，禁止
> - 枚举 -> int，C++11禁止。



从C++17标准开始，对有底层类型的枚举类型对象可以直接使用列表初始化。

这条规则适用于所有的强枚举类型，因为它们都有默认的底层类型int，而枚举类型就必须显式地指定底层类型才能使用该特性：

```C++
enum class Color {
  Red,
  Green,
  Blue
};
int main()
{
  Color c{ 5 };          // 编译成功
  Color c1 = 5;          // 编译失败
  Color c2 = { 5 };      // 编译失败
  Color c3(5);           // 编译失败
}
```



使用场景：

需要一个新整数类型，该类型必须严格区别于其他整型，也就是说不能够和其他整型做隐式转换，显然使用typedef的方法是不行的。另外，虽然通过定义一个类的方法可以到达这个目的，但是这个方法需要编写大量的代码来重载运算符，也不是一个理想的方案。

```C++
#include <iostream>
enum class Index : int {};

int main()
{
  Index a{ 5 };
  Index b{ 10 };
  // a = 12;
  // int c = b;
  std::cout << "a < b is " 
       << std::boolalpha 
       << (a < b) << std::endl;
}
```

>在C++17的标准库中新引入的std::byte类型就是用这种方法定义的。



# 使用using打开强枚举类型（C++20）

C++20标准扩展了using功能，它可以打开强枚举类型的命名空间。在一些情况下，这样做会让代码更加简洁易读，例如：

```C++
enum class Color {
  Red,
  Green,
  Blue
};

const char* ColorToString(Color c)
{
  switch (c)
  {
  case Color::Red: return "Red";
  case Color::Green: return "Green";
  case Color::Blue: return "Blue";
  default:
       return "none";
  }
}
```

在上面的代码中，函数ColorToString中需要不断使用Color::来指定枚举标识符，这显然会让代码变得冗余。通过using我们可以简化这部分代码：

```C++
const char* ColorToString(Color c)
{
  switch (c)
  {
  using enum Color;
  case Red: return "Red";
  case Green: return "Green";
  case Blue: return "Blue";
  default:
       return "none";
  }
}
```

以上代码使用using enum Color;将Color中的枚举标识符引入swtich-case作用域。

> review：
>
> - C++11之前，枚举会被引入被其被定义的作用域。
> - C++11，强枚举类型的作用域为其自身。



除了引入整个枚举标识符之外，using还可以指定引入的标识符，例如：

```C++
const char* ColorToString(Color c)
{
  switch (c)
  {
  using Color::Red;
  case Red: return "Red";
  case Color::Green: return "Green";
  case Color::Blue: return "Blue";
  default:
       return "none";
  }
}
```


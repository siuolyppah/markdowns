# 左值和右值

- ==左值==一般是指**一个指向特定内存的具有名称的值（==具名对象==）**，它有一个相对稳定的内存地址，并且有一段较长的生命周期。
- ==右值==则是**不指向稳定内存地址的匿名值（==不具名对象==）**，它的生命周期很短，通常是暂时性的。



基于这一特征，我们==可以用取地址符&来判断左值和右值==，能取到内存地址的值为左值，否则为右值。



>#### 💡 [深入理解左值和右值 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/513628368)

## 表达式

表达式的组成：

- 运算符
- 常量、变量

> 字面值(literal)和变量(variable)是最简单的表达式。

==一条表达式，包含一个或多个操作数，零个或多个运算符==。



==表达式是可求值的，对表达式求值可得到一个结果，这个结果有两个属性==：

- 类型：类型确定了表达式能进行哪些操作。

  如int、string、引用类型、类类型等。

- 值类别



## 值类别

自C++11开始，==表达式的值分为==`左值(lvalue, left value)`、`将亡值(xvalue, expiring value)`、`纯右值(pvalue, pure ravlue)`以及两种混合类别`泛左值(glvalue, generalized lvalue)`和`右值(rvalue, right value)`五种。

![img](%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8.assets/epub_40870001_8.jpeg)



这五种类别的分类基于表达式的两个特征：

- 具名(identity)：

  可以确定表达式是否与另一表达式指代同一实体，例如通过比较它们所标识的对象或函数的（直接或间接获得的）地址

- 可被移动：

  移动构造函数、移动赋值运算符或实现了移动语义的其他函数重载能够绑定于这个表达式



结合上述两个特征，对五种表达式值类别进行重新定义：

- ==lvalue:具名且不可被移动==
- ==xvaue:具名且可被移动==
- ==prvalue:不具名且可被移动==
- ==glvalue:具名，lvalue和xvalue都属于glvalue==
- ==rvalue:可被移动的表达式，prvalue和xvalue都属于rvalue==



### 左值

左值具有以下特征：

- 可通过取地址运算符获取其地址
- 可修改的左值可用作内建赋值和内建符合赋值运算符的左操作数
- 可以用来初始化左值引用



常见的左值：

- 变量名、函数名以及数据成员名
- 返回左值引用的函数调用
- 由赋值运算符或复合赋值运算符连接的表达式，如(a=b, a-=b等)
- 解引用表达式*ptr
- 前置自增和自减表达式(++a, ++b)
- 成员访问（点）运算符的结果
- 由指针访问成员（ `->` ）运算符的结果
- 下标运算符的结果(`[]`)
- 字符串字面值("abc")



### 纯右值

常见的纯右值：

- 字面值(字符串字面值除外)，例如1，'a', true等
- 返回值为非引用的函数调用或操作符重载，例如：str.substr(1, 2), str1 + str2, or it++
- 后置自增和自减表达式(a++, a--)
- 算术表达式
- 逻辑表达式
- 比较表达式
- 取地址表达式
- lambda表达式



### 将亡值

将亡值，是具名并且可移动的==临时值==。



常见的将亡值：

- 返回右值引用T&&的函数返回值
- std::move的返回值
- 或者转换为T&&的类型转换函数的返回值



## 引用

区分左值引用和右值引用的API：

```C++
std::is_lvalue_reference
is_rvalue_reference
  
int a = 1;
int &ra = a;
int &&b = 1;

std::cout << std::is_lvalue_reference<decltype(ra)>::value << std::endl;

std::cout << std::is_rvalue_reference<decltype(ra)>::value << std::endl;

std::cout << std::is_rvalue_reference<decltype(b)>::value << std::endl;
```







# 左值引用

- 非常量左值引用，仅可引用左值对象。
- 常量左值引用，可以引用：
  - 左值对象
  - 右值对象

```C++
int &x1 = 7;          // 编译错误
const int &x = 11;    // 编译成功
```

>常量左值引用有时候是必要的：
>
>复制构造函数和复制赋值运算符函数，通常情况下我们实现的这两个函数的形参都是一个常量左值引用。



```C++
class X {
public:
  X() {}
  X(const X&) {}
  X& operator = (const X&) { return *this; }
};

X make_x()
{
  return X();
}

int main() 
{
  X x1;
  X x2(x1);
  X x3(make_x());
  x3 = make_x();
}
```

如果这里将类X的复制构造函数和复制赋值函数形参类型的常量性删除，则X x3(make_x());和x3 = make_x();这两句代码会编译报错，因为非常量左值引用无法绑定到make_x()产生的右值。



# 右值引用

- 仅可引用右值。

- 使用右值引用，可以延长临时对象生命周期。减少对象复制，提升程序性能。

  ```C++
  # include <iostream>
  
  class X {
  public:
    X() { std::cout << "X ctor" << std::endl; }
    X(const X&x) { std::cout << "X copy ctor" << std::endl; }
    ~X() { std::cout << "X dtor" << std::endl; }
    void show() { std::cout << "show X" << std::endl; }
  };
  
  X make_x()
  {
    X x1;
    return x1;
  }
  
  int main()
  {
    X &&x2 = make_x();
    x2.show();
  }
  ```

  >用GCC编译以上代码需要加上命令行参数`-fno-elide-constructors`用于==关闭函数返回值优化（RVO）==。

  上述代码将输出：

  ```
  X ctor
  X copy ctor
  X dtor
  show X
  X dtor
  ```

  第一次是make_x函数中x1的默认构造，第二次是return x1引发的复制构造。不同的是，由于x2是一个右值引用，**引用的对象是函数make_x返回的临时对象**，因此该临时对象的生命周期得到延长，所以我们可以在X &&x2 = make_x()语句结束后继续调用show函数而不会发生任何问题。



# 总结

表达式能求值，其结果有两种属性：

- 类型：如int、string、引用等。
- 值类别。



按照表达式是否具名、是否可移动，值类别被划分为：

- 左值：

  - 表达式的结果，能取地址。

- 纯右值：

  - 表达式的结果，不能取地址。

  - 右值一般是不可寻址的常量，或在表达式求值过程中创建的无名临时对象，短暂性的。

  - 右值都存储在临时对象中，当右值被使用之后程序会马上销毁对象并释放内存。即不具名。

    > 可以通过常引用、或右值引用，延长它的生命周期。

  - 对于右值，编译器会优先选择使用移动构造函数去构造目标对象。当移动构造函数不存在的时候才会退而求其次地使用复制构造函数。

- xvalue（将亡值）：只有两种获得方式

  - 返回右值引用的函数的调用表达式,如 `static_cast<T&&>(t);` 该表达式得到一个 xvalue

  - 临时量实质化（C++17）：

    每当纯右值出现在一个需要泛左值的地方时，临时量实质化都会发生，也就是说都会创建一个临时对象并且使用纯右值对其进行初始化，这也符合纯右值的概念，而这里的临时对象就是一个将亡值。

    ```C++
    struct X {
        int a;
    };
    
    int main()
    {
        int b = X().a;
    }
    ```





- 自动生成的移动构造函数的条件：
  1. 没有任何复制函数
  2. 没有任何移动函数
  3. 没有析构函数

- 应保证移动构造函数不抛出异常：
  - 编写代码保证
  - 使用noexcept说明符限制该函数。这样当函数抛出异常的时候，程序不会再继续执行而是调用std::terminate中止执行以免造成其他不良影响。



- 引用折叠的规则：

  只要有左值引用参与进来，最后推导的结果就是一个左值引用。

  ![epub_40870001_9](%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8.assets/epub_40870001_9.jpeg)

- 万能引用：

  万能引用既可以绑定左值也可以绑定右值，甚至const和volatile的值都可以绑定。

  ```C++
  void foo(int &&i) {}    // i为右值引用
  
  template<class T>
  void bar(T &&t) {}        // t为万能引用
  
  int get_val() { return 5; }
  
  int &&x = get_val();      // x为右值引用
  auto &&y = get_val();     // y为万能引用
  ```

  > 注意：
  >
  > - std::move的源码：一定会得到一个右值引用。
  >
  > - std::forward的源码：会得到对应值类别的引用类型。



